<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Void: HANGAR & STARS (2D)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #three-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        #gameCanvas {
            z-index: 1;
            opacity: 0;
            transition: opacity 1s;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }
        #boss-hud {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 1s;
        }
        #boss-name {
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: #ff4d4d;
            text-shadow: 0 0 10px #ff0000;
            margin-bottom: 5px;
        }
        #boss-health-container {
            width: 60%;
            max-width: 600px;
            height: 10px;
            background: rgba(50, 0, 0, 0.5);
            border: 1px solid #ff0000;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }
        #boss-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff8800);
            box-shadow: 0 0 15px #ff0000;
            transition: width 0.1s linear;
        }
        #boss-shield-bar {
            width: 0%;
            height: 4px;
            background: #00ffff;
            box-shadow: 0 0 10px #00ffff;
            position: absolute;
            top: 0; left: 0;
            transition: width 0.1s;
            z-index: 2;
        }
        #player-hud {
            align-self: flex-start;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .hud-text {
            font-size: 18px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #menu-screen {
            pointer-events: auto;
            background: rgba(0,0,0,0.4);
        }
        #level-select-screen, #expert-level-select-screen, #hangar-screen {
            pointer-events: auto;
            background: rgba(0,0,0,0.9);
            opacity: 0; /* Hidden by default */
            pointer-events: none;
        }
        #game-over-screen {
            background: rgba(0, 0, 0, 0.85);
            opacity: 0;
        }
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
        }
        .title-text {
            font-size: 64px;
            font-weight: 900;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 10px;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        .subtitle-text {
            font-size: 24px;
            color: #ccc;
            margin-bottom: 40px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .btn-container {
            display: flex;
            gap: 20px;
        }
        .btn {
            background: rgba(0, 0, 0, 0.6);
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 20px 40px;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            z-index: 30;
            position: relative;
        }
        .btn:hover {
            background: #00ffff;
            color: black;
            box-shadow: 0 0 40px #00ffff;
        }
        .btn-hard {
            border-color: #ff4444;
            color: #ff4444;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.2);
        }
        .btn-hard:hover {
            background: #ff4444;
            color: white;
            box-shadow: 0 0 40px #ff4444;
        }
        /* HANGAR BUTTON & SCREEN */
        .hangar-toggle-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            border: 2px solid #ffd700;
            color: #ffd700;
            background: rgba(0,0,0,0.6);
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: 0.3s;
        }
        .hangar-toggle-btn:hover {
            background: #ffd700;
            color: black;
            box-shadow: 0 0 20px #ffd700;
        }
        .upgrade-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .upgrade-card {
            width: 220px;
            padding: 15px;
            border: 1px solid #444;
            background: rgba(20,20,20,0.8);
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .upgrade-val {
            font-size: 18px; color: #ccc; margin: 10px 0;
        }
        .locked { border-color: #555; color: #555; }
        .locked h3 { color: #555; }
        
        /* LEVEL SELECT GRID */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }
        .level-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #444;
            color: #444;
            font-size: 24px;
            font-weight: bold;
            cursor: not-allowed;
            transition: all 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        .level-btn.active {
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            cursor: pointer;
            background: rgba(0, 50, 50, 0.5);
        }
        .level-btn.active:hover {
            background: #00ffff;
            color: black;
            box-shadow: 0 0 30px #00ffff;
            transform: scale(1.1);
        }

        /* RED THEME FOR EXPERT */
        .red-theme .title-text {
            color: #ff4444 !important;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        .red-theme .level-btn.active {
            border-color: #ff4444;
            color: #ff4444;
            background: rgba(50, 0, 0, 0.5);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
        }
        .red-theme .level-btn.active:hover {
            background: #ff4444;
            color: black;
            box-shadow: 0 0 30px #ff4444;
        }
        .red-theme .btn {
            border-color: #ff4444;
            color: #ff4444;
        }
        .red-theme .btn:hover {
            background: #ff4444;
            color: white;
        }

        /* Wave Announcement Text */
        #wave-announcement {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px #00ffff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s, transform 0.5s;
            transform: scale(0.5);
            letter-spacing: 10px;
            z-index: 15;
        }
        .phase-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            font-family: monospace;
            text-align: right;
        }
        .controls-hint {
            margin-top: 20px;
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            font-family: monospace;
        }

        /* DEV/MOD MENU STYLES */
        .dev-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            pointer-events: auto;
        }
        .dev-toggle {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff4444;
            color: #ff4444;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 12px;
            padding: 5px 10px;
            cursor: pointer;
            backdrop-filter: blur(2px);
            margin-bottom: 5px;
            transition: 0.2s;
        }
        .dev-toggle:hover { background: #ff4444; color: black; }
        .dev-menu {
            display: none;
            background: rgba(20, 0, 0, 0.9);
            border: 1px solid #ff4444;
            padding: 10px;
            border-radius: 4px;
            width: 180px;
        }
        .dev-btn {
            background: #300;
            border: 1px solid #600;
            color: #f88;
            width: 100%;
            padding: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: center;
        }
        .dev-btn:hover { background: #f00; color: white; border-color: #f00; }
        .dev-btn:active { transform: translateY(1px); }
    </style>
</head>
<body>

    <!-- 3D Background -->
    <div id="three-container"></div>
    <canvas id="gameCanvas"></canvas>

    <!-- White Flash Overlay -->
    <div id="flash-overlay"></div>

    <!-- DEV MENU OVERLAY -->
    <div class="dev-overlay">
        <button class="dev-toggle" onclick="toggleDevMenu()">[ DEV TOOLS ]</button>
        <div id="dev-menu" class="dev-menu">
            <button class="dev-btn" onclick="requestWarp()">‚è© WARP TO WAVE...</button>
            <button class="dev-btn" onclick="setupTerminatorRun()">‚öôÔ∏è SETUP: TERMINATOR</button>
            <button id="god-mode-btn" class="dev-btn" onclick="toggleGodMode()">üõ°Ô∏è GOD MODE: OFF</button>
            <button class="dev-btn" onclick="killAllEnemies()">üíÄ KILL ALL</button>
        </div>
    </div>

    <div id="ui-layer">
        <div id="boss-hud">
            <div id="boss-name">System Core: Omega</div>
            <div id="boss-health-container">
                <div id="boss-shield-bar"></div>
                <div id="boss-health-bar"></div>
            </div>
        </div>
        <div id="player-hud">
            <div class="hud-text">HP: <span id="player-hp">100</span>%</div>
            <div class="hud-text">SCORE: <span id="score">0</span></div>
            <div class="hud-text" style="color: #ffd700;">STARS: <span id="stars-display">0</span></div>
            <div class="hud-text" style="font-size: 14px; margin-top: 5px; color: #aaa;">STAGE: <span id="stage-display">1</span></div>
        </div>
        <div class="phase-indicator" id="phase-debug">INIT</div>
        <div id="wave-announcement">WAVE 1</div>
    </div>

    <!-- MAIN MENU -->
    <div id="menu-screen" class="screen-overlay">
        <div class="title-text" style="color: #00ffff;">NEON VOID</div>
        <div class="subtitle-text">SELECT DIFFICULTY</div>
        <div class="btn-container">
            <button id="start-hard-btn" class="btn btn-hard">EXPERT</button>
            <button id="start-easy-btn" class="btn">BEGINNER</button>
        </div>
        <div class="controls-hint">ARROWS / WASD to Move &nbsp;|&nbsp; MOUSE to Follow</div>
    </div>

    <!-- ROOKIE LEVEL SELECT -->
    <div id="level-select-screen" class="screen-overlay">
        <button class="hangar-toggle-btn" onclick="openHangar('easy')">üõ†Ô∏è HANGAR</button>
        <div class="title-text" style="color: #00ffff;">BEGINNER CAMPAIGN</div>
        <div class="level-grid">
            <button class="level-btn active" onclick="launchMission('easy', 1)">01</button>
            <button class="level-btn active" onclick="launchMission('easy', 2)">02</button>
            <button class="level-btn">03</button>
            <!-- ... -->
        </div>
        <button class="btn" onclick="resetToMenu()">BACK</button>
    </div>

    <!-- EXPERT LEVEL SELECT -->
    <div id="expert-level-select-screen" class="screen-overlay red-theme">
        <button class="hangar-toggle-btn" onclick="openHangar('hard')">üõ†Ô∏è HANGAR</button>
        <div class="title-text">EXPERT CAMPAIGN</div>
        <div class="level-grid">
            <button class="level-btn active" onclick="launchMission('hard', 1)">01</button>
            <button class="level-btn">02</button>
            <button class="level-btn">03</button>
            <!-- ... -->
        </div>
        <button class="btn" onclick="resetToMenu()">BACK</button>
    </div>

    <!-- HANGAR SCREEN -->
    <div id="hangar-screen" class="screen-overlay">
        <div class="title-text" id="hangar-title">HANGAR</div>
        <div style="font-size: 24px; color: #ffd700; margin-bottom: 20px;">STARS: <span id="hangar-stars">0</span></div>
        
        <!-- Ship Preview Canvas in Hangar -->
        <canvas id="hangarShipCanvas" width="200" height="200" style="background: rgba(0,20,20,0.5); border: 2px solid #00ffff; border-radius: 10px; margin-bottom: 20px;"></canvas>

        <div class="upgrade-row">
            <div class="upgrade-card">
                <h3 style="color: #00ffff;">HEALTH</h3>
                <div class="upgrade-val" id="hp-lvl">Lvl 0</div>
                <div class="upgrade-val" id="hp-bonus" style="font-size:14px; color:#0f0;">+0 HP</div>
                <button id="btn-upg-hp" class="btn" style="font-size: 14px; padding: 10px;" onclick="upgradeHealth()">UPGRADE</button>
            </div>
            <div class="upgrade-card">
                <h3 style="color: #00ffff;">MAIN CANNON</h3>
                <div class="upgrade-val">Lvl 1</div>
                <button class="btn" style="font-size: 14px; padding: 10px; opacity: 0.5; cursor: not-allowed;">UPGRADE</button>
            </div>
            <div class="upgrade-card locked">
                <h3>LASER</h3>
                <div class="upgrade-val">LOCKED</div>
                <button class="btn" style="font-size: 14px; padding: 10px; background: #333; border-color: #555; cursor: not-allowed;">LOCKED</button>
            </div>
        </div>
        <button class="btn" onclick="closeHangar()">EXIT HANGAR</button>
    </div>

    <div id="game-over-screen" class="screen-overlay">
        <div class="title-text" id="game-over-title">Mission Failed</div>
        <button id="retry-btn" class="btn" onclick="resetToMenu()">Main Menu</button>
    </div>

    <script>
        const STATE = { 
            MENU: 'menu', 
            LEVEL_SELECT: 'level_select', 
            PLAYING: 'playing', 
            GAMEOVER: 'gameover', 
            VICTORY_SEQUENCE: 'victory_sequence',
            HANGAR: 'hangar'
        };
        let gameState = STATE.MENU;
        let width, height;
        let currentLevelIndex = 1;
        let activeDifficultyMode = 'easy'; // 'easy' or 'hard'
        let currentHangarMode = 'easy'; // Tracks which hangar is open
        let godModeActive = false;

        // --- DATA PERSISTENCE ---
        // Separate data for Easy (Rookie) and Hard (Expert)
        let gameData = JSON.parse(localStorage.getItem('neonVoidData_v2')) || {
            easy: { stars: 0, healthLvl: 0 },
            hard: { stars: 0, healthLvl: 0 }
        };

        function saveData() {
            localStorage.setItem('neonVoidData_v2', JSON.stringify(gameData));
        }

        // --- UPGRADE CONFIGURATION ---
        const HEALTH_UPGRADES = {
            costs: [110, 150, 200, 600, 1100], // Increased by 100
            bonuses: [5, 10, 15, 20, 50]     // HP added at Level 1, 2, 3, 4, 5 (Cumulative)
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const flashOverlay = document.getElementById('flash-overlay');
        const menuScreen = document.getElementById('menu-screen');
        const levelSelectScreen = document.getElementById('level-select-screen');
        const expertSelectScreen = document.getElementById('expert-level-select-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const hangarScreen = document.getElementById('hangar-screen');
        
        function resizeGame() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resizeGame();
        window.addEventListener('resize', resizeGame);

        // UI
        const bossHud = document.getElementById('boss-hud');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossShieldBar = document.getElementById('boss-shield-bar');
        const bossName = document.getElementById('boss-name');
        const playerHud = document.getElementById('player-hud');
        const playerHpEl = document.getElementById('player-hp');
        const scoreEl = document.getElementById('score');
        const starsDisplayEl = document.getElementById('stars-display');
        const stageDisplayEl = document.getElementById('stage-display');
        const gameOverTitle = document.getElementById('game-over-title');
        const phaseDebug = document.getElementById('phase-debug');
        const waveText = document.getElementById('wave-announcement');

        // Input
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, s: false, a: false, d: false
        };
        const mouse = { x: width / 2, y: height - 150, down: false, targetX: width / 2, targetY: height - 150 };
        let isTouch = false;

        /**
         * THREE.JS BACKGROUND & EFFECTS
         */
        let scene, camera, renderer;
        let menuCore, stars, bossPhase2Mesh, bossShieldMesh;
        let isPhase2Active = false;
        
        // Supernova Variables
        let supernovaMesh, supernovaParticles;
        let supernovaVelocities = [];
        let isSupernovaExploding = false;

        // 2D DROPS
        let dropMeshes = []; // Not used in 2D mode, keeping var clean

        function initThreeMenu() {
            if (typeof THREE === 'undefined') return;

            try {
                const container = document.getElementById('three-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x050505, 0.002);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 50;

                renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.domElement.id = 'menuCanvas';
                container.appendChild(renderer.domElement);

                // 1. Menu Core
                const geometry = new THREE.IcosahedronGeometry(10, 1);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.8 });
                menuCore = new THREE.Mesh(geometry, material);
                scene.add(menuCore);

                // 2. Stars
                const starGeo = new THREE.BufferGeometry();
                const starCount = 2000;
                const posArray = new Float32Array(starCount * 3);
                for(let i=0; i<starCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 400;
                starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const starMat = new THREE.PointsMaterial({ size: 0.5, color: 0xffffff });
                stars = new THREE.Points(starGeo, starMat);
                scene.add(stars);

                // 3. PHASE 2 BOSS MESH (System Core)
                const bossGeo = new THREE.TorusKnotGeometry(12, 3, 100, 16);
                const bossMat = new THREE.MeshBasicMaterial({ color: 0xff3300, wireframe: true });
                bossPhase2Mesh = new THREE.Mesh(bossGeo, bossMat);
                bossPhase2Mesh.visible = false;
                bossPhase2Mesh.position.z = -20;
                scene.add(bossPhase2Mesh);
                
                const ringGeo = new THREE.RingGeometry(20, 22, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                bossPhase2Mesh.add(ring);

                // 4. BOSS SHIELD (New)
                const shieldGeo = new THREE.SphereGeometry(25, 32, 32);
                const shieldMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.3 });
                bossShieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
                bossShieldMesh.visible = false;
                bossPhase2Mesh.add(bossShieldMesh); 

                // 5. SUPERNOVA ASSETS
                const snGeo = new THREE.SphereGeometry(1, 32, 32);
                const snMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0, wireframe: true });
                supernovaMesh = new THREE.Mesh(snGeo, snMat);
                supernovaMesh.visible = false;
                scene.add(supernovaMesh);

                const pGeo = new THREE.BufferGeometry();
                const pCount = 2000;
                const pPos = new Float32Array(pCount * 3);
                supernovaVelocities = [];
                for(let i=0; i<pCount; i++) {
                    pPos[i*3] = 0; pPos[i*3+1] = 0; pPos[i*3+2] = 0;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const speed = 2 + Math.random() * 4;
                    supernovaVelocities.push(
                        Math.sin(phi) * Math.cos(theta) * speed,
                        Math.sin(phi) * Math.sin(theta) * speed,
                        Math.cos(phi) * speed
                    );
                }
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const pMat = new THREE.PointsMaterial({ color: 0xff5500, size: 0.8, transparent: true });
                supernovaParticles = new THREE.Points(pGeo, pMat);
                supernovaParticles.visible = false;
                scene.add(supernovaParticles);

                animateThree();
            } catch (e) { console.warn("Error initializing 3D:", e); }
        }

        function triggerSupernova() {
            if(!supernovaMesh || !supernovaParticles) return;
            isSupernovaExploding = true;
            
            if(bossPhase2Mesh && isPhase2Active) {
                supernovaMesh.position.copy(bossPhase2Mesh.position);
                supernovaParticles.position.copy(bossPhase2Mesh.position);
            } else {
                 supernovaMesh.position.set(0, 20, -20);
                 supernovaParticles.position.set(0, 20, -20);
            }

            if(bossPhase2Mesh) bossPhase2Mesh.visible = false;
            
            supernovaMesh.scale.set(1,1,1);
            supernovaMesh.material.opacity = 1;
            supernovaMesh.visible = true;

            const positions = supernovaParticles.geometry.attributes.position.array;
            positions.fill(0);
            supernovaParticles.geometry.attributes.position.needsUpdate = true;
            supernovaParticles.material.opacity = 1;
            supernovaParticles.visible = true;
        }

        function animateThree() {
            requestAnimationFrame(animateThree);
            
            // GOD MODE ANIMATION
            if(godModeActive) {
                const gmBtn = document.getElementById('god-mode-btn');
                if(gmBtn) {
                    const time = Date.now() * 0.005;
                    const hue = (time * 50) % 360;
                    gmBtn.style.borderColor = `hsl(${hue}, 100%, 50%)`;
                    gmBtn.style.boxShadow = `0 0 15px hsl(${hue}, 100%, 50%)`;
                    gmBtn.style.transform = `scale(${1 + Math.sin(time) * 0.05})`;
                    gmBtn.style.color = "white";
                }
            } else {
                const gmBtn = document.getElementById('god-mode-btn');
                if(gmBtn && gmBtn.style.transform !== '') {
                    gmBtn.style.borderColor = '#600';
                    gmBtn.style.boxShadow = 'none';
                    gmBtn.style.transform = 'scale(1)';
                    gmBtn.style.color = '#f88';
                }
            }

            // SHOW CORE IN MENU OR LEVEL SELECT OR HANGAR
            if ((gameState === STATE.MENU || gameState === STATE.LEVEL_SELECT || gameState === STATE.HANGAR) && menuCore) {
                menuCore.rotation.x += 0.005; menuCore.rotation.y += 0.01; menuCore.visible = true;
            } else if (menuCore) { menuCore.visible = false; }

            // BOSS UPDATES
            if (isPhase2Active && bossPhase2Mesh && !isSupernovaExploding) {
                bossPhase2Mesh.visible = true;
                bossPhase2Mesh.rotation.x += 0.02; bossPhase2Mesh.rotation.y += 0.03;
                
                let targetX = 0;
                if (boss) {
                    targetX = (boss.x / width) * 120 - 60;
                    
                    if (bossShieldMesh) {
                        bossShieldMesh.visible = (boss.shieldHp > 0);
                        bossShieldMesh.rotation.y -= 0.05;
                        bossShieldMesh.material.opacity = 0.2 + Math.sin(Date.now() * 0.01) * 0.1;
                    }
                }

                const baseScale = 4 + Math.sin(Date.now() * 0.01) * 0.5; 
                bossPhase2Mesh.scale.set(baseScale, baseScale, baseScale);
                bossPhase2Mesh.position.x += (targetX - bossPhase2Mesh.position.x) * 0.2;
                bossPhase2Mesh.position.y += (0 - bossPhase2Mesh.position.y) * 0.2;
                if(bossPhase2Mesh.material) bossPhase2Mesh.material.color.setHex(0xff3300);
                bossPhase2Mesh.rotation.z = 0;
            } else if (bossPhase2Mesh && !isSupernovaExploding) { bossPhase2Mesh.visible = false; }

            if (isSupernovaExploding) {
                const scale = supernovaMesh.scale.x + 3;
                supernovaMesh.scale.set(scale, scale, scale);
                supernovaMesh.rotation.y += 0.1;
                supernovaMesh.material.opacity -= 0.015;

                const positions = supernovaParticles.geometry.attributes.position.array;
                for(let i=0; i<supernovaVelocities.length/3; i++) {
                    positions[i*3] += supernovaVelocities[i*3];
                    positions[i*3+1] += supernovaVelocities[i*3+1];
                    positions[i*3+2] += supernovaVelocities[i*3+2];
                }
                supernovaParticles.geometry.attributes.position.needsUpdate = true;
                supernovaParticles.material.opacity -= 0.01;

                if (supernovaMesh.material.opacity <= 0) {
                    isSupernovaExploding = false;
                    supernovaMesh.visible = false;
                    supernovaParticles.visible = false;
                }
            }

            if (stars) { stars.rotation.y += 0.0005; stars.rotation.x += 0.0002; }
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // --- UPDATED INPUT HANDLING ---
        window.addEventListener('keydown', e => {
            if (gameState === STATE.PLAYING) {
                const k = e.key.toLowerCase();
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true; 
                if (keys.hasOwnProperty(k)) keys[k] = true;
                if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].indexOf(e.code) > -1) {
                    e.preventDefault();
                }
            }
        });

        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
            if (keys.hasOwnProperty(k)) keys[k] = false;
        });

        function updateInput(e) {
            if (gameState === STATE.PLAYING) e.preventDefault();
            let cx, cy;
            if (e.touches && e.touches.length > 0) {
                isTouch = true; cx = e.touches[0].clientX; cy = e.touches[0].clientY; mouse.down = true;
            } else {
                isTouch = false; cx = e.clientX; cy = e.clientY; mouse.down = e.buttons === 1;
            }
            mouse.targetX = cx; mouse.targetY = isTouch ? cy - 80 : cy;
        }
        window.addEventListener('mousemove', updateInput);
        window.addEventListener('mousedown', updateInput);
        window.addEventListener('mouseup', () => mouse.down = false);
        window.addEventListener('touchstart', updateInput, {passive: false});
        window.addEventListener('touchmove', updateInput, {passive: false});
        window.addEventListener('touchend', () => mouse.down = false);

        /**
         * GAME LOGIC
         */
        const ATTACK_SEQUENCE = ['laser', 'swarm', 'missiles', 'laser', 'laser', 'redLines', 'missiles', 'rings', 'laser', 'laser', 'swarm'];
        const TERMINATOR_SEQUENCE = ['terminator_fireballs', 'terminator_rapid', 'terminator_laser'];

        // --- DIFFICULTY SETTINGS ---
        const DIFFICULTY = {
            NORMAL: {
                name: "VETERAN",
                playerDamage: 5,
                swarmHp: 20,
                heavyHp: 80,
                laserHp: 60,
                bossHp: 5000,
                heavyAgile: true,
                enemyCountMult: 1.0, 
                fireRateMult: 1.0, 
                waveDelay: 60
            },
            EASY: {
                name: "ROOKIE",
                playerDamage: 10,
                swarmHp: 10,
                heavyHp: 40,
                laserHp: 30,
                bossHp: 2500, 
                heavyAgile: false,
                enemyCountMult: 0.5, 
                fireRateMult: 1.5, 
                waveDelay: 120
            }
        };
        let currentSettings = DIFFICULTY.NORMAL;

        class Particle {
            constructor(x, y, color, speed, size, life) {
                this.x = x; this.y = y; this.color = color;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = Math.random() * speed;
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.life = life; this.maxLife = life; this.size = size;
                this.decay = Math.random() * 0.05 + 0.92;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vx *= this.decay; this.vy *= this.decay;
                this.life--; this.size *= 0.95;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(0.1, this.size), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // NEW: 2D STAR & DROP SYSTEM
        class Drop {
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.type = type; // 'star' or 'health'
                this.active = true;
                this.rot = 0;
            }
            update() {
                // Move straight down at heavy enemy speed (approx 1.0)
                this.y += 1.0; 
                this.rot += 0.05;
                
                if (this.y > height + 20) {
                    this.active = false;
                }

                if (player && player.active) {
                    let dist = Math.hypot(this.x - player.x, this.y - player.y);
                    if (dist < 40) this.collect();
                }
            }
            collect() {
                this.active = false;
                
                if (this.type === 'star') {
                    // Add star to CURRENT difficulty bank
                    if (activeDifficultyMode === 'easy') {
                        gameData.easy.stars++;
                    } else {
                        gameData.hard.stars++;
                    }
                    saveData();
                    updateUI();
                    
                    // FX
                    for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, '#ffd700', 3, 2, 20));
                } else if (this.type === 'health') {
                    if (player.hp < player.maxHp) {
                        // Heal 10% of Max HP
                        const healAmount = player.maxHp * 0.1;
                        player.hp = Math.min(player.maxHp, player.hp + healAmount);
                        playerHpEl.innerText = Math.floor(player.hp);
                        for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#00ffff', 4, 3, 30));
                    }
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rot);
                
                if (this.type === 'star') {
                    // Draw Star Shape
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowBlur = 15; ctx.shadowColor = '#ffd700';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * 10,
                                   -Math.sin((18 + i * 72) * Math.PI / 180) * 10);
                        ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * 4,
                                   -Math.sin((54 + i * 72) * Math.PI / 180) * 4);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Health Pack (Blue Cross Box)
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = 'rgba(0, 50, 50, 0.8)';
                    ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
                    ctx.fillRect(-8, -8, 16, 16);
                    ctx.strokeRect(-8, -8, 16, 16);
                    
                    ctx.fillStyle = '#00ffff';
                    ctx.fillRect(-2, -5, 4, 10);
                    ctx.fillRect(-5, -2, 10, 4);
                }
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, vx, vy, type) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.type = type; this.active = true;
                if (type === 'player') {
                    this.color = '#00ffff'; this.size = 3; 
                    this.damage = currentSettings.playerDamage; 
                } else if (type === 'boss_orb') {
                    this.color = '#ffaa00'; this.size = 6; this.damage = 10;
                } else if (type === 'fireball') {
                    this.color = '#ff4400'; this.size = 12; this.damage = 15;
                } else if (type === 'saw') {
                    this.color = '#cccccc'; this.size = 15; this.damage = 15;
                } else if (type === 'boss_laser_bit') {
                    this.color = '#ff0055'; this.size = 4; this.damage = 15;
                } else if (type === 'missile') {
                    this.color = '#ff0000'; this.size = 5; this.damage = 20;
                    this.angle = Math.atan2(vy, vx); this.speed = 4;
                    this.guidanceTimer = 90; 
                }
            }
            update() {
                if (this.type === 'missile' && player.active && this.guidanceTimer > 0) {
                    let dx = player.x - this.x; let dy = player.y - this.y;
                    let targetAngle = Math.atan2(dy, dx);
                    let diff = targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.05;
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                    this.guidanceTimer--;
                    if (Math.random() > 0.5) particles.push(new Particle(this.x, this.y, '#555', 1, 3, 20));
                }
                
                // Fireball visual effect
                if (this.type === 'fireball') {
                     particles.push(new Particle(this.x, this.y, '#ffaa00', 1, 4, 10));
                }

                this.x += this.vx; this.y += this.vy;
                if (this.x < -100 || this.x > width + 100 || this.y < -100 || this.y > height + 100) this.active = false;
            }
            draw() {
                ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fillStyle = this.color;
                if (this.type === 'missile') {
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                    ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill();
                    ctx.restore();
                } else if (this.type === 'saw') {
                    ctx.save(); ctx.translate(this.x, this.y); 
                    ctx.rotate(frames * 0.5); // Spin
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    // Saw teeth
                    ctx.fillStyle = "#888";
                    for(let i=0; i<8; i++) {
                        ctx.rotate(Math.PI/4);
                        ctx.fillRect(12, -4, 8, 8);
                    }
                    ctx.fillStyle = "#ff0000";
                    ctx.beginPath(); ctx.arc(0,0, 5, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                } else {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
        }

        class Player {
            constructor() {
                this.x = width / 2; this.y = height - 100;
                this.active = true; this.iframes = 0; this.speed = 8;
                
                // CALCULATE MAX HP BASED ON UPGRADES
                let baseHp = 100;
                let bonusHp = 0;
                // Get upgrade level for current active difficulty mode
                const stats = gameData[activeDifficultyMode]; 
                const level = stats.healthLvl;
                
                // Cumulative logic: Sum all bonuses up to current level
                for(let i=0; i < level; i++) {
                    bonusHp += HEALTH_UPGRADES.bonuses[i];
                }
                
                this.maxHp = baseHp + bonusHp;
                this.hp = this.maxHp;
                
                // Set initial HUD
                playerHpEl.innerText = Math.floor(this.hp);
            }
            update() {
                if (!this.active) return;
                
                if (gameState === STATE.PLAYING) {
                    let dx = 0, dy = 0;
                    if (keys.ArrowUp || keys.w) dy -= this.speed;
                    if (keys.ArrowDown || keys.s) dy += this.speed;
                    if (keys.ArrowLeft || keys.a) dx -= this.speed;
                    if (keys.ArrowRight || keys.d) dx += this.speed;
                    if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
                    
                    if (dx !== 0 || dy !== 0) {
                        this.x += dx; this.y += dy;
                        mouse.targetX = this.x; mouse.targetY = this.y;
                    } else if (mouse.targetX !== undefined) {
                        this.x += (mouse.targetX - this.x) * 0.15;
                        this.y += (mouse.targetY - this.y) * 0.15;
                    }
                    this.x = Math.max(20, Math.min(width - 20, this.x));
                    this.y = Math.max(20, Math.min(height - 20, this.y));

                    if (frames % 6 === 0) {
                        bullets.push(new Bullet(this.x - 10, this.y - 10, 0, -15, 'player'));
                        bullets.push(new Bullet(this.x + 10, this.y - 10, 0, -15, 'player'));
                    }
                }
                
                if (this.iframes > 0) this.iframes--;
                particles.push(new Particle(this.x, this.y + 15, '#00ffff', 2, 4, 10));
            }
            draw() {
                if (!this.active && gameState !== STATE.VICTORY_SEQUENCE) return;
                
                // GOD MODE LASER DRAWING
                if (godModeActive && this.active && gameState === STATE.PLAYING) {
                    // Massive Laser Beam
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const beamWidth = 40 + Math.sin(Date.now() * 0.05) * 10;
                    
                    // Core
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(-beamWidth/4, -1000, beamWidth/2, 1000);
                    
                    // Outer Glow
                    ctx.shadowBlur = 30; ctx.shadowColor = '#00ffff';
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.fillRect(-beamWidth/2, -1000, beamWidth, 1000);
                    
                    // Hit Effect Logic (Kill enemies in path)
                    enemies.forEach(e => {
                        if(Math.abs(e.x - this.x) < beamWidth && e.y < this.y) {
                            e.hit(9999); // INSTA KILL
                            // Sparks
                            for(let i=0; i<3; i++) particles.push(new Particle(e.x, e.y, '#fff', 5, 3, 20));
                        }
                    });
                    
                    // Destroy Projectiles
                    bullets.forEach(b => {
                        if(b.type !== 'player' && Math.abs(b.x - this.x) < beamWidth && b.y < this.y) {
                            b.active = false;
                            particles.push(new Particle(b.x, b.y, '#00ffff', 3, 2, 10));
                        }
                    });

                    // Hit Boss
                    if(boss && boss.active && Math.abs(boss.x - this.x) < beamWidth + 50) {
                        boss.hit(10); // Massive damage per frame
                    }

                    ctx.restore();
                }

                if (this.iframes > 0 && Math.floor(frames / 4) % 2 === 0) return;
                ctx.save(); ctx.translate(this.x, this.y);
                
                // GOD MODE SCALE
                if(godModeActive) ctx.scale(4, 4); 

                ctx.shadowBlur = 20; ctx.shadowColor = '#00ffff'; ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(15, 15); ctx.lineTo(0, 10); ctx.lineTo(-15, 15); ctx.fill();
                ctx.fillStyle = '#00aaaa';
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(20, 10); ctx.lineTo(20, 25); ctx.lineTo(5, 15); ctx.fill();
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-20, 10); ctx.lineTo(-20, 25); ctx.lineTo(-5, 15); ctx.fill();
                ctx.restore(); ctx.shadowBlur = 0;
            }
            hit(damage) {
                if (this.iframes > 0 || !this.active) return;
                
                // GOD MODE CHECK
                if (godModeActive) return; 

                this.hp -= damage; this.iframes = 30;
                playerHpEl.innerText = Math.max(0, Math.floor(this.hp));
                ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);
                setTimeout(() => ctx.setTransform(1,0,0,1,0,0), 50);
                if (this.hp <= 0) {
                    this.active = false;
                    for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, '#00ffff', 5, 5, 60));
                    gameOver(false);
                }
            }
        }

        class SwarmEnemy {
            constructor(x, y) {
                this.x = x; this.y = y; this.origX = x; this.origY = y;
                this.active = true; 
                this.hp = currentSettings.swarmHp;
                this.timeOffset = Math.random() * 100;
                this.fireTimer = (Math.random() * 120 + 60) * currentSettings.fireRateMult; 
                this.points = 100;
            }
            update() {
                if (!this.active) return;
                this.x = this.origX + Math.sin((frames + this.timeOffset) * 0.05) * 50;
                this.y += 1.5;
                this.fireTimer--;
                if (this.fireTimer <= 0) {
                    let angle = Math.atan2(player.y - this.y, player.x - this.x);
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*4, Math.sin(angle)*4, 'boss_orb'));
                    this.fireTimer = (120 + Math.random() * 60) * currentSettings.fireRateMult;
                }
                if (this.y > height + 20) this.active = false;
            }
            draw() {
                if (!this.active) return;
                ctx.fillStyle = '#aa00aa'; ctx.shadowBlur = 5; ctx.shadowColor = '#ff00ff';
                ctx.beginPath(); ctx.moveTo(this.x, this.y - 10); ctx.lineTo(this.x + 10, this.y);
                ctx.lineTo(this.x, this.y + 10); ctx.lineTo(this.x - 10, this.y); ctx.fill();
                ctx.shadowBlur = 0;
            }
            hit(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.active = false; score += this.points; scoreEl.innerText = score;
                    for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, '#ff00ff', 3, 3, 30));
                    // DROP 1 STAR
                    drops.push(new Drop(this.x, this.y, 'star'));
                }
            }
        }

        class HeavyStriker {
            constructor(x, y) {
                this.x = x; this.y = y; this.vx = (Math.random() < 0.5 ? -1 : 1) * 2;
                this.active = true; 
                this.hp = currentSettings.heavyHp;
                this.fireTimer = (Math.random() * 60 + 60) * currentSettings.fireRateMult;
                this.points = 300;
            }
            update() {
                if(!this.active) return;
                this.y += 1.0; 
                if (currentSettings.heavyAgile) {
                    this.x += this.vx;
                    if (this.x < 50 || this.x > width - 50) this.vx *= -1;
                }
                this.fireTimer--;
                if(this.fireTimer <= 0) {
                    let angle = Math.atan2(player.y - this.y, player.x - this.x);
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*4, Math.sin(angle)*4, 'boss_orb'));
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle-0.3)*4, Math.sin(angle-0.3)*4, 'boss_orb'));
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle+0.3)*4, Math.sin(angle+0.3)*4, 'boss_orb'));
                    this.fireTimer = 100 * currentSettings.fireRateMult; 
                }
                if(this.y > height + 50) this.active = false;
            }
            draw() {
                if(!this.active) return;
                ctx.fillStyle = '#ff4400';
                ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 20);
                ctx.lineTo(this.x + 20, this.y - 10);
                ctx.lineTo(this.x - 20, this.y - 10);
                ctx.fill();
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(this.x - 5, this.y - 5, 10, 10);
                ctx.shadowBlur = 0;
            }
            hit(damage) {
                this.hp -= damage;
                if(this.hp <= 0) {
                    this.active = false; score += this.points; scoreEl.innerText = score;
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#ff4400', 4, 5, 40));
                    // DROP 3 STARS
                    for(let k=0; k<3; k++) drops.push(new Drop(this.x + (k*10 - 10), this.y, 'star'));
                }
            }
        }

        class LaserEnemy {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.active = true; 
                this.hp = currentSettings.laserHp; 
                this.state = 'enter'; 
                this.timer = 0;
                this.points = 500;
            }
            update() {
                if(!this.active) return;
                this.timer++;
                if (this.state === 'enter') {
                    this.y += 3;
                    if (this.y > 100 + Math.random() * 100) this.state = 'charge';
                } else if (this.state === 'charge') {
                    let trackSpeed = currentSettings.heavyAgile ? 1.0 : 0.5;
                    if (player.x > this.x) this.x += trackSpeed;
                    else this.x -= trackSpeed;
                    if (this.timer > 100) {
                        this.state = 'fire';
                        this.timer = 0;
                    }
                } else if (this.state === 'fire') {
                    if (this.timer > 30) {
                        if (Math.abs(player.x - this.x) < 20) player.hit(2);
                        if (this.timer > 80) {
                            this.state = 'leave';
                        }
                    }
                } else if (this.state === 'leave') {
                    this.y += 5;
                    if (this.y > height + 50) this.active = false;
                }
            }
            draw() {
                if(!this.active) return;
                if (this.state === 'fire' && this.timer > 30) {
                    ctx.save();
                    ctx.shadowBlur = 20; ctx.shadowColor = 'cyan';
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                    ctx.fillRect(this.x - 10, this.y, 20, height);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(this.x - 4, this.y, 8, height);
                    ctx.restore();
                } else if (this.state === 'charge') {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${Math.random()})`;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, height);
                    ctx.stroke();
                }
                ctx.fillStyle = '#00aaaa';
                ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 15);
                ctx.lineTo(this.x + 15, this.y - 15);
                ctx.lineTo(this.x - 15, this.y - 15);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            hit(damage) {
                this.hp -= damage;
                if(this.hp <= 0) {
                    this.active = false; score += this.points; scoreEl.innerText = score;
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#00aaaa', 4, 5, 40));
                    // DROP HEALTH
                    drops.push(new Drop(this.x, this.y, 'health'));
                }
            }
        }

        class Boss {
            constructor() {
                this.x = width / 2; this.y = -100; this.targetY = 150;
                this.maxHp = currentSettings.bossHp;
                this.hp = this.maxHp;
                this.active = false; 
                this.flashTimer = 0;
                this.sequenceIndex = 0; this.phase = 'entry';
                this.currentAttack = 'idle'; this.attackTimer = 0;
                this.laserCharge = 0; this.laserActive = false; this.redLines = [];
                this.isPhaseTwo = false; 
                this.spawnRate = 90 * currentSettings.fireRateMult;
                this.damageMultiplier = 1; 
                this.laserAngle = Math.PI / 2;
                this.isDesperationMode = false;
                this.isTerminator = false; // New Property for Terminator
                this.targetX = width / 2; 
                this.shredderMode = false; // Phase 2 Terminator
                this.sawRingTimer = 0; // Phase 3 Terminator
                
                // Shield Props
                this.shieldHp = 0;
                this.maxShieldHp = 1000;
            }

            // Called when starting Stage 2 specifically
            initAsStage2() {
                this.isPhaseTwo = false; 
                this.isTerminator = true;
                this.damageMultiplier = 1.5;
                this.maxHp = 3000; // Terminator Health
                this.hp = this.maxHp;
                this.shredderMode = false;
                
                bossName.innerText = "TERMINATOR";
                bossName.style.color = "#ff0000";
                
                isPhase2Active = false; // Disable standard boss mesh
            }

            activate() {
                this.active = true;
                bossHud.style.opacity = 1;
            }

            update() {
                if (!this.active) return;
                if (this.flashTimer > 0) this.flashTimer--;

                // --- TERMINATOR SPECIFIC PHASE LOGIC ---
                if (this.isTerminator) {
                    // OPERATION SHREDDER ( < 1500 HP)
                    if (!this.shredderMode && this.hp <= 1500) {
                        this.shredderMode = true;
                        this.triggerShredderMode();
                    }

                    // PHASE 3: RING OF SAWS (< 750 HP)
                    if (this.hp <= 750) {
                        this.sawRingTimer++;
                        // Every 2 seconds (120 frames)
                        if (this.sawRingTimer >= 120) {
                            this.sawRingTimer = 0;
                            // Fire HUGE RING OF SAWS
                            for(let i=0; i<12; i++) {
                                let angle = (Math.PI*2/12) * i;
                                bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'saw'));
                            }
                            waveText.innerText = "SAW RING DETECTED";
                            waveText.style.opacity = 1;
                            waveText.style.transform = "scale(0.8)";
                            setTimeout(() => { waveText.style.opacity = 0; }, 1000);
                        }
                    }

                    // Side Saw Logic (Shredder Mode)
                    if (this.shredderMode && frames % 60 === 0) {
                        // Spawn saw from boss SIDES (wings) instead of walls
                        // Boss is scaled 4x, roughly 80-100px wide from center
                        bullets.push(new Bullet(this.x - 100, this.y, -5, 5, 'saw')); // Left wing fire left-down
                        bullets.push(new Bullet(this.x + 100, this.y, 5, 5, 'saw'));  // Right wing fire right-down
                    }
                } else {
                     // Standard Boss Phase 2 Logic
                     if (!this.isPhaseTwo && this.hp < this.maxHp / 2) {
                        this.triggerPhaseTwo();
                     }
                }
                
                if (!this.isDesperationMode && this.hp <= 1000 && this.isPhaseTwo && !this.isTerminator) {
                    this.isDesperationMode = true;
                    for(let i=0; i<20; i++) particles.push(new Particle(this.x, this.y, '#ffffff', 5, 3, 20));
                }

                if (this.phase === 'entry') {
                    this.y += (this.targetY - this.y) * 0.05;
                    if (Math.abs(this.y - this.targetY) < 1) {
                        this.phase = 'fight';
                        this.startNextAttack();
                    }
                    return;
                }

                // MOVEMENT LOGIC
                if (this.isTerminator) {
                    if (this.currentAttack !== 'terminator_laser') {
                        // Strafe
                        this.x = width/2 + Math.sin(frames * 0.03) * 150;
                    }
                } else {
                    // Standard boss movement
                    if (!(this.isDesperationMode && this.laserActive)) {
                        this.x = width/2 + Math.sin(frames * 0.02) * 100;
                    }
                }
                
                this.attackTimer++;
                
                // Passive Spawn (Disabled for Terminator)
                if (!this.isTerminator && frames % Math.floor(this.spawnRate) === 0 && this.currentAttack !== 'laser' && this.phase === 'fight') {
                      enemies.push(new SwarmEnemy(this.x - 40, this.y));
                      enemies.push(new SwarmEnemy(this.x + 40, this.y));
                }
                this.handleAttack();
            }

            triggerShredderMode() {
                waveText.innerText = "OPERATION SHREDDER";
                waveText.style.color = "#ff0000";
                waveText.style.opacity = 1;
                waveText.style.transform = "scale(1)";
                setTimeout(() => { waveText.style.opacity = 0; }, 2000);
                
                for(let i=0; i<50; i++) particles.push(new Particle(this.x, this.y, '#ff0000', 8, 5, 60));
            }

            triggerPhaseTwo() {
                this.isPhaseTwo = true;
                this.damageMultiplier = 2; 
                this.spawnRate = 45 * currentSettings.fireRateMult;        
                for(let i=0; i<100; i++) particles.push(new Particle(this.x, this.y, '#ff3300', 10, 8, 80));
                
                bossName.innerText = "System Core: OMEGA UNLEASHED";
                bossName.style.color = "#ffaa00";
                isPhase2Active = true;

                // TRIGGER SHIELD
                this.shieldHp = 100;
                bossShieldBar.style.width = "100%";

                createShockwave(this.x, this.y);
                
                flashOverlay.style.transition = 'none';
                flashOverlay.style.opacity = 1;
                void flashOverlay.offsetWidth;
                flashOverlay.style.transition = 'opacity 2s ease-out';
                flashOverlay.style.opacity = 0;
            }

            startNextAttack() {
                let seq = this.isTerminator ? TERMINATOR_SEQUENCE : ATTACK_SEQUENCE;
                
                if (this.sequenceIndex >= seq.length) this.sequenceIndex = 0;
                this.currentAttack = seq[this.sequenceIndex];
                this.attackTimer = 0;
                this.sequenceIndex++;
                
                if(this.isTerminator) {
                     phaseDebug.innerText = `PHASE: ${this.currentAttack.replace('terminator_', '').toUpperCase()}`;
                } else {
                     phaseDebug.innerText = `PHASE: ${this.currentAttack.toUpperCase()}`;
                }
                
                this.laserCharge = 0; this.laserActive = false; this.redLines = [];
                this.laserAngle = Math.PI / 2;
                this.lockTarget = false; // New flag for Terminator Laser
            }

            handleAttack() {
                switch(this.currentAttack) {
                    
                    // --- TERMINATOR ATTACKS ---
                    case 'terminator_fireballs':
                        if (this.attackTimer % 40 === 0 && this.attackTimer < 200) {
                            // Aimed fireballs from side cannons
                            let angle = Math.atan2(player.y - this.y, player.x - this.x);
                            bullets.push(new Bullet(this.x - 60, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'fireball'));
                            bullets.push(new Bullet(this.x + 60, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'fireball'));
                        }
                        if (this.attackTimer > 250) this.startNextAttack();
                        break;

                    case 'terminator_rapid':
                         if (this.attackTimer % 10 === 0 && this.attackTimer < 150) {
                            // Rapid fire straight down with slight spread
                            bullets.push(new Bullet(this.x, this.y + 40, (Math.random()-0.5)*2, 8, 'fireball'));
                         }
                         if (this.attackTimer > 200) this.startNextAttack();
                         break;

                    case 'terminator_laser':
                        // Charge for 60 frames, track player
                        if (this.attackTimer < 60) {
                            this.laserCharge = this.attackTimer / 60;
                            // Track Player
                            // CORRECT TRACKING LOGIC: Store the raw angle to player
                            let target = Math.atan2(player.y - this.y, player.x - this.x);
                            this.laserAngle = target; 
                        } else if (this.attackTimer === 60) {
                            // LOCK ANGLE - Stop updating this.laserAngle
                            this.lockTarget = true; 
                        } else if (this.attackTimer < 160) {
                            // FIRE (Angle is locked from previous step)
                            this.laserActive = true;
                            
                            // Hit detection (Raycast style)
                            // We need to check if player is near the line defined by this.x, this.y and angle
                            let angle = this.laserAngle; 
                            let dx = player.x - this.x; let dy = player.y - this.y;
                            // Rotate point to local space where laser is Y axis
                            // Rotation amount = -angle + PI/2 (to align laser with Y)
                            let rAngle = -angle + Math.PI/2;
                            
                            let rx = dx * Math.cos(rAngle) - dy * Math.sin(rAngle);
                            let ry = dx * Math.sin(rAngle) + dy * Math.cos(rAngle);
                            
                            // Beam width 30, must be in front of boss (ry > 0)
                            if (Math.abs(rx) < 30 && ry > 0) player.hit(2);
                            
                        } else {
                            this.laserActive = false;
                            this.lockTarget = false;
                            if (this.attackTimer > 200) this.startNextAttack();
                        }
                        break;

                    // --- STANDARD BOSS ATTACKS ---
                    case 'laser':
                        if (this.attackTimer < 60) {
                            this.laserCharge = this.attackTimer / 60;
                            if (this.isDesperationMode) {
                                let target = Math.atan2(player.y - this.y, player.x - this.x);
                                let diff = target - this.laserAngle;
                                while (diff < -Math.PI) diff += Math.PI * 2;
                                while (diff > Math.PI) diff -= Math.PI * 2;
                                this.laserAngle += diff * 0.1;
                            } else {
                                this.laserAngle = Math.PI / 2;
                            }
                        } else if (this.attackTimer < 160) {
                            this.laserActive = true; 
                            let hit = false;
                            if (this.isDesperationMode) {
                                let dx = player.x - this.x; let dy = player.y - this.y;
                                let angle = -(this.laserAngle - Math.PI/2);
                                let rx = dx * Math.cos(angle) - dy * Math.sin(angle);
                                if (Math.abs(rx) < 30 && dy > 0) hit = true; 
                            } else {
                                if (Math.abs(player.x - this.x) < 30) hit = true;
                            }
                            if (hit) player.hit(2 * this.damageMultiplier);
                            if (frames % 4 === 0) {
                                ctx.translate(Math.random()*4-2, 0);
                                setTimeout(()=>ctx.setTransform(1,0,0,1,0,0), 20);
                            }
                        } else {
                            this.laserActive = false;
                            if (this.attackTimer > 200) this.startNextAttack();
                        }
                        break;

                    case 'swarm':
                         if (this.attackTimer === 1) {
                            let count = this.isPhaseTwo ? 15 : 10;
                            count = Math.floor(count * currentSettings.enemyCountMult);
                            for(let i=0; i<count; i++) enemies.push(new SwarmEnemy(Math.random() * width, -50 - (i*50)));
                        }
                        if (this.attackTimer > 400) this.startNextAttack();
                        break;
                    case 'redLines':
                        if (this.attackTimer === 1) {
                            let count = Math.ceil(5 * currentSettings.enemyCountMult);
                            for(let i=0; i<count; i++) this.redLines.push({x: Math.random() * width, width: 2, damage: false});
                        }
                        if (this.attackTimer > 100 && this.attackTimer < 160) {
                            this.redLines.forEach(l => {
                                l.width = 40; l.damage = true;
                                if (l.damage && Math.abs(player.x - l.x) < 20) player.hit(1 * this.damageMultiplier);
                            });
                        }
                        if (this.attackTimer > 200) this.startNextAttack();
                        break;
                    case 'rings':
                        if (this.attackTimer % 40 === 0 && this.attackTimer < 300) {
                            let count = this.isPhaseTwo ? 24 : 16;
                            count = Math.floor(count * currentSettings.enemyCountMult);
                            for (let i = 0; i < count; i++) {
                                let angle = (Math.PI * 2 / count) * i + (this.attackTimer * 0.01);
                                bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*5, Math.sin(angle)*5, 'boss_orb'));
                            }
                        }
                        if (this.attackTimer > 350) this.startNextAttack();
                        break;
                    case 'missiles':
                        if (this.attackTimer % 30 === 0 && this.attackTimer < 200) {
                            bullets.push(new Bullet(this.x - 50, this.y, -3, -3, 'missile'));
                            bullets.push(new Bullet(this.x + 50, this.y, 3, -3, 'missile'));
                            if(this.isPhaseTwo) bullets.push(new Bullet(this.x, this.y - 20, 0, -4, 'missile'));
                        }
                        if (this.attackTimer > 300) this.startNextAttack();
                        break;
                    case 'fireballs': // Default boss fireball
                        if (this.attackTimer % 30 === 0 && this.attackTimer < 200) {
                            bullets.push(new Bullet(this.x - 40, this.y, (player.x - (this.x-40))*0.02, (player.y-this.y)*0.02, 'fireball'));
                            bullets.push(new Bullet(this.x + 40, this.y, (player.x - (this.x+40))*0.02, (player.y-this.y)*0.02, 'fireball'));
                        }
                        if (this.attackTimer > 250) this.startNextAttack();
                        break;
                }
            }

            draw() {
                if (!this.active) return;
                
                // --- TERMINATOR DRAWING (GIANT RED SHIP) ---
                if (this.isTerminator) {
                      ctx.save(); ctx.translate(this.x, this.y);
                      
                      // TERMINATOR LASER
                      if (this.currentAttack === 'terminator_laser') {
                          // Rotate so +Y points to the target angle
                          // Angle 0 is Right (+X). Angle PI/2 is Down (+Y).
                          // To align +Y (Down) to Target Angle, we rotate by (Target - PI/2)
                          ctx.rotate(this.laserAngle - Math.PI/2);
                          
                          // Charge indicator
                          if (this.attackTimer < 60) {
                               ctx.fillStyle = `rgba(255, 0, 0, ${this.laserCharge})`;
                               // Draw at center (0,0) instead of offset
                               ctx.beginPath(); ctx.arc(0, 0, this.laserCharge * 20, 0, Math.PI*2); ctx.fill();
                               // Aim Line
                               ctx.strokeStyle = "rgba(255, 0, 0, 0.3)"; ctx.lineWidth = 2;
                               ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 1000); ctx.stroke();
                          }
                          // Fire Beam
                          else if (this.laserActive) {
                              ctx.save();
                              ctx.shadowBlur = 40; ctx.shadowColor = "red";
                              ctx.fillStyle = "rgba(255, 0, 0, 0.9)";
                              // Draw beam from center downwards
                              ctx.fillRect(-30, 0, 60, height * 1.5);
                              ctx.fillStyle = "white";
                              ctx.fillRect(-10, 0, 20, height * 1.5);
                              ctx.restore();
                          }
                          
                          // Undo rotation for ship body
                          ctx.rotate(-(this.laserAngle - Math.PI/2));
                      }
                      
                      // Scale up 4x
                      ctx.scale(4, 4);
                      
                      // Draw Ship Body (Red Version of Player)
                      ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000'; ctx.fillStyle = '#ffcccc';
                      // Rotate 180 degrees to face down
                      ctx.rotate(Math.PI);
                      
                      // Main Wing
                      ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(15, 15); ctx.lineTo(0, 10); ctx.lineTo(-15, 15); ctx.fill();
                      // Inner Details (Dark Red)
                      ctx.fillStyle = '#880000';
                      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(20, 10); ctx.lineTo(20, 25); ctx.lineTo(5, 15); ctx.fill();
                      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-20, 10); ctx.lineTo(-20, 25); ctx.lineTo(-5, 15); ctx.fill();
                      
                      // Cannon Glow
                      ctx.fillStyle = "#ffaa00";
                      ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

                      if (this.flashTimer > 0) {
                          ctx.globalCompositeOperation = 'source-over';
                          ctx.fillStyle = "white";
                          ctx.fill();
                      }

                      ctx.restore();
                      return; 
                }

                // --- STANDARD BOSS DRAWING ---
                ctx.save(); ctx.translate(this.x, this.y);

                if (this.currentAttack === 'laser') {
                    ctx.rotate(this.laserAngle - Math.PI / 2);

                    if (this.attackTimer < 60) {
                        ctx.strokeStyle = `rgba(255, 0, 0, ${Math.random()})`; ctx.lineWidth = 1;
                        for(let i=0; i<5; i++) {
                            ctx.beginPath(); ctx.moveTo((Math.random()-0.5)*200, 200); ctx.lineTo(0, 40); ctx.stroke();
                        }
                        ctx.fillStyle = `rgba(255, 200, 200, ${this.laserCharge})`;
                        ctx.beginPath(); ctx.arc(0, 50, this.laserCharge * 20, 0, Math.PI*2); ctx.fill();
                    } else if (this.laserActive) {
                        ctx.save(); ctx.shadowBlur = 40; ctx.shadowColor = "red";
                        const beamWidth = 60 + Math.sin(frames * 0.5) * 5;
                        ctx.fillStyle = this.isPhaseTwo ? "rgba(255, 50, 0, 0.9)" : "rgba(255, 0, 0, 0.7)";
                        ctx.fillRect(-beamWidth/2, 0, beamWidth, height * 1.5); 
                        ctx.fillStyle = "white"; ctx.fillRect(-beamWidth/4, 0, beamWidth/2, height * 1.5);
                        ctx.restore();
                        
                        if (Math.random() > 0.5) particles.push(new Particle(this.x, this.y + 50, '#ff5500', 5, 8, 30));
                    }
                }

                if (this.isPhaseTwo) ctx.globalAlpha = 0.5;

                if (this.flashTimer > 0) { ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = '#ffffff'; }
                else { ctx.shadowBlur = 30; ctx.shadowColor = '#ff3300'; ctx.fillStyle = '#880000'; }
                
                ctx.rotate(-(this.laserAngle - Math.PI / 2)); 

                ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.fill();
                if (this.flashTimer > 0) ctx.globalCompositeOperation = 'source-over';
                
                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(0, 0, 60, frames * 0.1, frames * 0.1 + 4); ctx.stroke();
                ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0, 0, 70, -frames * 0.1, -frames * 0.1 + 4); ctx.stroke();
                ctx.restore();
                ctx.globalAlpha = 1.0;

                if (this.currentAttack === 'redLines') {
                    this.redLines.forEach(l => {
                        ctx.save();
                        if (!l.damage) {
                            ctx.strokeStyle = `rgba(255, 0, 0, ${Math.abs(Math.sin(frames * 0.2))})`;
                            ctx.lineWidth = 2; ctx.setLineDash([10, 10]);
                            ctx.beginPath(); ctx.moveTo(l.x, 0); ctx.lineTo(l.x, height); ctx.stroke();
                        } else {
                            ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000';
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.fillRect(l.x - 20, 0, 40, height);
                            ctx.fillStyle = '#fff'; ctx.fillRect(l.x - 2, 0, 4, height);
                        }
                        ctx.restore();
                    });
                }
            }
            hit(damage) {
                if (this.phase !== 'fight') return;
                
                // SHIELD MECHANIC
                if (this.shieldHp > 0) {
                    this.shieldHp -= damage;
                    bossShieldBar.style.width = `${(this.shieldHp / this.maxShieldHp) * 100}%`;
                    if (this.shieldHp <= 0) {
                        bossShieldBar.style.width = "0%";
                        // Shield Break Effect
                        for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, '#00ffff', 5, 5, 40));
                    }
                    return; // Damage absorbed
                }

                this.hp -= damage;
                this.flashTimer = 4;
                bossHealthBar.style.width = `${(this.hp / this.maxHp) * 100}%`;
                if (this.hp <= 0 && this.active) {
                    this.active = false; bossHealthBar.style.width = '0%';
                    isPhase2Active = false;
                    this.isTerminator = false;
                    for(let i=0; i<100; i++) {
                        particles.push(new Particle(this.x, this.y, '#ffaa00', 10, 8, 100));
                        particles.push(new Particle(this.x, this.y, '#ffffff', 15, 5, 120));
                    }
                    
                    flashOverlay.style.transition = 'none';
                    flashOverlay.style.opacity = 1;
                    void flashOverlay.offsetWidth;
                    flashOverlay.style.transition = 'opacity 2s ease-out';
                    flashOverlay.style.opacity = 0;
                    
                    // BOSS DROP (15 STARS)
                    let dropCount = 15;
                    for(let k=0; k<dropCount; k++) {
                        // Spread drops WIDELY (500px range)
                        drops.push(new Drop(this.x + (Math.random()-0.5)*500, this.y, 'star'));
                    }

                    triggerSupernova();
                    startVictorySequence();
                }
            }
        }

        function createShockwave(x, y) {
             for(let i=0; i<360; i+=10) {
                 let angle = i * Math.PI / 180;
                 particles.push(new Particle(x, y, '#ffffff', 10, 3, 20));
             }
        }

        let currentWave = 0;
        let waveClearCheckReady = false; 

        function startWave(wave) {
            currentWave = wave;
            waveClearCheckReady = false; 
            
            let maxWaves = (activeDifficultyMode === 'easy' && currentLevelIndex === 2) ? 15 : 10;
            
            waveText.innerText = currentWave === maxWaves ? "BOSS WARNING" : `WAVE ${currentWave}`;
            waveText.style.color = "#fff"; // reset color in case shredder changed it
            waveText.style.opacity = 1;
            waveText.style.transform = "scale(1.2)";
            
            setTimeout(() => {
                waveText.style.opacity = 0;
                waveText.style.transform = "scale(0.5)";
                spawnWaveEnemies(wave);
            }, 2000);
        }

        function spawnWaveEnemies(wave) {
            let maxDelay = 0;
            const countMult = currentSettings.enemyCountMult;

            // --- STAGE 2 LOGIC (15 Waves, Terminator Boss) ---
            if (activeDifficultyMode === 'easy' && currentLevelIndex === 2) {
                
                if (wave >= 1 && wave <= 4) {
                    // Intro Waves
                    let count = Math.ceil((12 + wave * 2) * countMult);
                    for(let i=0; i<count; i++) {
                        let d = i * (400 - wave * 20); if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 5) {
                    // Mini Boss Check
                    enemies.push(new HeavyStriker(width/2, -100));
                    setTimeout(() => enemies.push(new HeavyStriker(width/2 - 100, -200)), 500);
                    setTimeout(() => enemies.push(new HeavyStriker(width/2 + 100, -200)), 500);
                    maxDelay = 1000;
                } else if (wave >= 6 && wave <= 9) {
                    // Laser + Swarm
                    enemies.push(new LaserEnemy(width * 0.2, -100));
                    enemies.push(new LaserEnemy(width * 0.8, -100));
                    if(wave > 7) enemies.push(new LaserEnemy(width * 0.5, -200));
                    
                    let count = Math.ceil(20 * countMult);
                    for(let i=0; i<count; i++) {
                        let d = 1000 + i * 200; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 10) {
                    // Heavy + Laser
                    enemies.push(new HeavyStriker(width/3, -100));
                    enemies.push(new HeavyStriker(width*2/3, -100));
                    enemies.push(new LaserEnemy(width/2, -200));
                    maxDelay = 500;
                } else if (wave >= 11 && wave <= 14) {
                    // Chaos Waves
                    let laserCount = Math.floor((wave - 9) / 2) + 1;
                    for(let l=0; l<laserCount; l++) {
                        setTimeout(() => enemies.push(new LaserEnemy(width * ((l+1)/(laserCount+1)), -100)), l*500);
                    }
                    
                    let heavyCount = 2;
                    for(let h=0; h<heavyCount; h++) {
                        setTimeout(() => enemies.push(new HeavyStriker(Math.random()*width, -100)), 2000 + h*1000);
                    }

                    let count = Math.ceil(30 * countMult);
                    for(let i=0; i<count; i++) {
                        let d = i * 150; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 15) {
                    // BOSS: TERMINATOR
                    boss.activate();
                    boss.initAsStage2(); 
                }

            } else {
                // --- DEFAULT LOGIC (Stage 1 / Expert) ---
                if (wave === 1) {
                    let count = Math.ceil(10 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = i*400; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 2) {
                    let count = Math.ceil(16 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = i*300; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 3) {
                    let count = Math.ceil(24 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = i*200; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 4) {
                    setTimeout(() => enemies.push(new HeavyStriker(width/2, -100)), 0);
                    let count = Math.ceil(15 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = 1000 + i*300; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 5) {
                    enemies.push(new HeavyStriker(width/4, -100));
                    enemies.push(new HeavyStriker(width*2/4, -150));
                    enemies.push(new HeavyStriker(width*3/4, -100));
                    let count = Math.ceil(20 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = 2000 + i*250; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                    maxDelay = 2000 + count*250;
                } else if (wave === 6) {
                    enemies.push(new LaserEnemy(width*0.2, -100));
                    enemies.push(new LaserEnemy(width*0.8, -100));
                    let count = Math.ceil(20 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = i*200; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 7) {
                    enemies.push(new LaserEnemy(width*0.1, -100));
                    enemies.push(new LaserEnemy(width*0.9, -100));
                    setTimeout(() => enemies.push(new HeavyStriker(width/2, -100)), 500);
                    setTimeout(() => enemies.push(new HeavyStriker(width/4, -100)), 1000);
                    setTimeout(() => enemies.push(new HeavyStriker(width*3/4, -100)), 1500);
                    maxDelay = 1500;
                } else if (wave === 8) {
                    enemies.push(new LaserEnemy(width/2, -100));
                    enemies.push(new LaserEnemy(200, -200));
                    enemies.push(new LaserEnemy(width-200, -200));
                    let count = Math.ceil(30 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = 1000 + i*200; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                    maxDelay = 1000 + count*200;
                } else if (wave === 9) {
                    enemies.push(new LaserEnemy(width*0.2, -100));
                    enemies.push(new LaserEnemy(width*0.8, -100));
                    enemies.push(new HeavyStriker(width/3, -200));
                    enemies.push(new HeavyStriker(width*2/3, -200));
                    let count = Math.ceil(40 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = 500 + i*150; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                    maxDelay = 500 + count*150;
                } else if (wave === 10) {
                    boss.activate();
                }
            }

            setTimeout(() => {
                waveClearCheckReady = true;
            }, maxDelay + 500);
        }

        let player, boss;
        let particles = [], bullets = [], enemies = [], drops = [];
        let score = 0, frames = 0;
        let victoryTimer = 0;

        function showExpertSelect() {
            gameState = STATE.LEVEL_SELECT;
            menuScreen.style.opacity = '0';
            menuScreen.style.pointerEvents = 'none';
            expertSelectScreen.style.opacity = '1';
            expertSelectScreen.style.pointerEvents = 'auto';
        }

        function showRookieSelect() {
            gameState = STATE.LEVEL_SELECT;
            menuScreen.style.opacity = '0';
            menuScreen.style.pointerEvents = 'none';
            levelSelectScreen.style.opacity = '1';
            levelSelectScreen.style.pointerEvents = 'auto';
        }

        // --- HANGAR LOGIC ---
        function openHangar(mode) {
            gameState = STATE.HANGAR;
            currentHangarMode = mode; // Store mode for upgrades
            
            // Determine stats based on mode
            const stats = (mode === 'easy') ? gameData.easy : gameData.hard;
            
            document.getElementById('hangar-stars').innerText = stats.stars;
            document.getElementById('hangar-title').innerText = (mode === 'easy' ? "ROOKIE" : "EXPERT") + " HANGAR";
            
            // Update Health Card UI
            updateHangarUI();

            // Hide other screens
            levelSelectScreen.style.opacity = '0'; levelSelectScreen.style.pointerEvents = 'none';
            expertSelectScreen.style.opacity = '0'; expertSelectScreen.style.pointerEvents = 'none';
            hangarScreen.style.opacity = '1'; hangarScreen.style.pointerEvents = 'auto';

            // Draw Ship Preview
            const hCanvas = document.getElementById('hangarShipCanvas');
            const hCtx = hCanvas.getContext('2d');
            hCtx.clearRect(0,0,200,200);
            
            hCtx.save();
            hCtx.translate(100, 100);
            hCtx.scale(2, 2); 
            hCtx.shadowBlur = 20; hCtx.shadowColor = '#00ffff'; hCtx.fillStyle = '#fff';
            hCtx.beginPath(); hCtx.moveTo(0, -20); hCtx.lineTo(15, 15); hCtx.lineTo(0, 10); hCtx.lineTo(-15, 15); hCtx.fill();
            hCtx.fillStyle = '#00aaaa';
            hCtx.beginPath(); hCtx.moveTo(0, 0); hCtx.lineTo(20, 10); hCtx.lineTo(20, 25); hCtx.lineTo(5, 15); hCtx.fill();
            hCtx.beginPath(); hCtx.moveTo(0, 0); hCtx.lineTo(-20, 10); hCtx.lineTo(-20, 25); hCtx.lineTo(-5, 15); hCtx.fill();
            hCtx.restore();
        }

        function closeHangar() {
            gameState = STATE.LEVEL_SELECT; 
            hangarScreen.style.opacity = '0'; hangarScreen.style.pointerEvents = 'none';
            
            const title = document.getElementById('hangar-title').innerText;
            if(title.includes("EXPERT")) {
                expertSelectScreen.style.opacity = '1'; expertSelectScreen.style.pointerEvents = 'auto';
            } else {
                levelSelectScreen.style.opacity = '1'; levelSelectScreen.style.pointerEvents = 'auto';
            }
        }

        function updateHangarUI() {
            const stats = (currentHangarMode === 'easy') ? gameData.easy : gameData.hard;
            document.getElementById('hangar-stars').innerText = stats.stars;

            // Health Upgrade UI Logic
            const hpLvl = stats.healthLvl;
            const hpBtn = document.getElementById('btn-upg-hp');
            const hpLvlEl = document.getElementById('hp-lvl');
            const hpBonusEl = document.getElementById('hp-bonus');

            let totalBonus = 0;
            for(let i=0; i<hpLvl; i++) totalBonus += HEALTH_UPGRADES.bonuses[i];

            hpLvlEl.innerText = "Lvl " + hpLvl;
            hpBonusEl.innerText = "+" + totalBonus + " HP";

            if (hpLvl >= 5) {
                hpBtn.innerText = "MAXED";
                hpBtn.style.opacity = 0.5;
                hpBtn.style.cursor = "default";
                hpBtn.onclick = null;
            } else {
                const cost = HEALTH_UPGRADES.costs[hpLvl];
                hpBtn.innerText = `UPGRADE (${cost} ‚≠ê)`;
                hpBtn.style.opacity = 1;
                hpBtn.style.cursor = "pointer";
                hpBtn.onclick = upgradeHealth; // Re-bind
            }
        }

        function upgradeHealth() {
            const stats = (currentHangarMode === 'easy') ? gameData.easy : gameData.hard;
            const currentLvl = stats.healthLvl;

            if (currentLvl >= 5) return;

            const cost = HEALTH_UPGRADES.costs[currentLvl];

            if (stats.stars >= cost) {
                stats.stars -= cost;
                stats.healthLvl++;
                saveData();
                updateHangarUI();
            } else {
                alert("Not enough stars!"); // Simple feedback
            }
        }

        function updateUI() {
            if(activeDifficultyMode === 'easy') {
                starsDisplayEl.innerText = gameData.easy.stars;
            } else {
                starsDisplayEl.innerText = gameData.hard.stars;
            }
        }

        function launchMission(mode, levelIndex) {
            currentSettings = mode === 'hard' ? DIFFICULTY.NORMAL : DIFFICULTY.EASY;
            activeDifficultyMode = mode;
            currentLevelIndex = levelIndex;
            
            // Hide all menus
            menuScreen.style.opacity = '0'; menuScreen.style.pointerEvents = 'none';
            levelSelectScreen.style.opacity = '0'; levelSelectScreen.style.pointerEvents = 'none';
            expertSelectScreen.style.opacity = '0'; expertSelectScreen.style.pointerEvents = 'none';
            gameOverScreen.style.opacity = '0'; gameOverScreen.style.pointerEvents = 'none';
            hangarScreen.style.opacity = '0'; hangarScreen.style.pointerEvents = 'none';
            
            document.activeElement.blur();

            player = new Player();
            boss = new Boss();
            bullets = []; particles = []; enemies = []; drops = [];
            score = 0; frames = 0;
            scoreEl.innerText = '0'; playerHpEl.innerText = '100';
            stageDisplayEl.innerText = levelIndex;
            bossHealthBar.style.width = '100%';
            bossShieldBar.style.width = '0%';
            bossName.innerText = "System Core: Omega"; 
            bossName.style.color = "#ff4d4d";
            
            updateUI(); // Set star count

            gameState = STATE.PLAYING;
            isPhase2Active = false;
            
            playerHud.style.opacity = '1'; canvas.style.opacity = '1';
            bossHud.style.opacity = 0; 
            
            mouse.targetX = width/2; mouse.targetY = height - 100;

            // START WAVE 1
            currentWave = 0;
            startWave(1);
        }

        function startVictorySequence() {
            gameState = STATE.VICTORY_SEQUENCE;
            victoryTimer = 0;
            enemies = [];
            bullets = [];
            bossHud.style.opacity = 0;
            waveText.innerText = "MISSION COMPLETE";
            waveText.style.opacity = 1;
            waveText.style.transform = "scale(1)";
            waveText.style.color = "#00ff00";
            waveText.style.textShadow = "0 0 20px #00ff00";
        }

        function resetToMenu() {
            gameState = STATE.MENU;
            menuScreen.style.opacity = '1'; menuScreen.style.pointerEvents = 'auto';
            levelSelectScreen.style.opacity = '0'; levelSelectScreen.style.pointerEvents = 'none';
            expertSelectScreen.style.opacity = '0'; expertSelectScreen.style.pointerEvents = 'none';
            gameOverScreen.style.opacity = '0'; gameOverScreen.style.pointerEvents = 'none';
            playerHud.style.opacity = '0';
            canvas.style.opacity = '0'; 
            bossHud.style.opacity = 0;
            enemies = []; bullets = []; particles = []; drops = [];
            isSupernovaExploding = false;
            if(supernovaMesh) supernovaMesh.visible = false;
            if(supernovaParticles) supernovaParticles.visible = false;
            
            // Clean up 3D drops
            dropMeshes.forEach(d => { if(d.mesh) { scene.remove(d.mesh); d.mesh.geometry.dispose(); d.mesh.material.dispose(); } });
            dropMeshes = [];
        }

        function gameOver(win) {
            gameState = STATE.GAMEOVER;
            gameOverScreen.style.opacity = '1'; gameOverScreen.style.pointerEvents = 'auto';
            gameOverTitle.innerText = win ? "STAGE CLEARED" : "MISSION FAILED";
            gameOverTitle.style.color = win ? "#00ff00" : "#ff0000";
            waveText.style.opacity = 0;
        }

        function animateGame() {
            requestAnimationFrame(animateGame);
            ctx.fillStyle = 'rgba(5, 5, 5, 0.4)'; ctx.fillRect(0, 0, width, height);
            if (frames % 2 === 0) { ctx.fillStyle = `rgba(255, 255, 255, ${Math.random()})`; ctx.fillRect(Math.random() * width, 0, 2, 2); }
            if (gameState === STATE.MENU) return;

            frames++;
            if (gameState === STATE.PLAYING || gameState === STATE.GAMEOVER || gameState === STATE.VICTORY_SEQUENCE) {
                
                let maxWaves = (activeDifficultyMode === 'easy' && currentLevelIndex === 2) ? 15 : 10;

                if (gameState === STATE.PLAYING && currentWave < maxWaves && enemies.length === 0 && waveClearCheckReady) {
                    if (frames % 60 === 0) { 
                        startWave(currentWave + 1);
                    }
                }

                if (boss && boss.active) { boss.update(); boss.draw(); }
                
                if (player) {
                    if (gameState === STATE.PLAYING) {
                        player.update();
                        player.draw();
                        for (let i = enemies.length - 1; i >= 0; i--) {
                            let e = enemies[i]; e.update(); e.draw(); 
                            if (!e.active) enemies.splice(i, 1);
                        }
                        
                        // DROPS
                        for (let i = drops.length - 1; i >= 0; i--) {
                            let d = drops[i]; d.update(); d.draw();
                            if (!d.active) drops.splice(i, 1);
                        }

                        for (let i = bullets.length - 1; i >= 0; i--) {
                            let b = bullets[i]; b.update(); b.draw();
                            if (!b.active) { bullets.splice(i, 1); continue; }
                            
                            if (b.type === 'player') {
                                let hit = false;
                                if (boss.active) {
                                    let dx = b.x - boss.x; let dy = b.y - boss.y;
                                    if (Math.sqrt(dx*dx + dy*dy) < 60) { 
                                         boss.hit(b.damage); b.active = false; hit = true;
                                         particles.push(new Particle(b.x, b.y, '#ffaa00', 2, 2, 10));
                                    }
                                }
                                if (!hit) {
                                    enemies.forEach(e => {
                                        if (e.active && Math.abs(b.x - e.x) < 20 && Math.abs(b.y - e.y) < 20) {
                                            e.hit(b.damage); b.active = false;
                                        }
                                    });
                                }
                            } else {
                                let dx = b.x - player.x; let dy = b.y - player.y;
                                if (Math.sqrt(dx*dx + dy*dy) < 15) { 
                                    player.hit(b.damage); b.active = false;
                                    particles.push(new Particle(b.x, b.y, '#00ffff', 2, 2, 10));
                                }
                            }
                        }
                    } else if (gameState === STATE.VICTORY_SEQUENCE) {
                        player.draw(); 
                        
                        // AUTO COLLECT DROPS ON VICTORY
                        drops.forEach(d => { d.x += (player.x - d.x)*0.1; d.y += (player.y - d.y)*0.1; if(Math.abs(d.x-player.x)<20) d.collect(); d.draw(); });

                        victoryTimer++;
                        if (victoryTimer <= 100) {
                            player.x += (Math.random() - 0.5) * 2;
                            if(frames % 5 === 0) {
                                particles.push(new Particle(player.x, player.y + 20, '#00ffff', 1, 3, 5));
                            }
                        }
                        if (victoryTimer > 100) {
                            player.y -= 12;
                            particles.push(new Particle(player.x, player.y + 20, '#00ffff', 2, 6, 15));
                            particles.push(new Particle(player.x - 5, player.y + 20, '#00ffff', 1, 3, 10));
                            particles.push(new Particle(player.x + 5, player.y + 20, '#00ffff', 1, 3, 10));

                            if (player.y < -50) {
                                gameOver(true);
                            }
                        }
                    }
                }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1);
            }
        }

        // --- DEV TOOLS LOGIC ---
        function toggleDevMenu() {
            const menu = document.getElementById('dev-menu');
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        }

        function requestWarp() {
            const wave = prompt("Enter Wave Number to Warp to (1-15):", "15");
            if(wave) {
                const waveNum = parseInt(wave);
                if(!isNaN(waveNum) && waveNum > 0) {
                    warpToWave(waveNum);
                }
            }
        }

        function warpToWave(n) {
            if(n < 1) n = 1;
            
            if (gameState !== STATE.PLAYING || activeDifficultyMode !== 'easy' || currentLevelIndex !== 2) {
                 launchMission('easy', 2);
                 setTimeout(() => {
                     enemies = []; bullets = []; drops = [];
                     startWave(n);
                 }, 100);
                 return;
            }
            enemies = []; bullets = []; drops = [];
            if(boss) boss.active = false;
            bossHud.style.opacity = 0;
            startWave(n);
        }

        function setupTerminatorRun() {
            launchMission('easy', 2);
        }

        function toggleGodMode() {
            godModeActive = !godModeActive;
            const btn = document.getElementById('god-mode-btn');
            
            if(gameState === STATE.PLAYING && player) {
                if(godModeActive) {
                    player.hp = 9999;
                    playerHpEl.innerText = "INF";
                    btn.innerText = "üõ°Ô∏è GOD MODE: ON";
                } else {
                    player.hp = 100;
                    playerHpEl.innerText = "100";
                    btn.innerText = "üõ°Ô∏è GOD MODE: OFF";
                }
            } else {
                btn.innerText = godModeActive ? "üõ°Ô∏è GOD MODE: ON" : "üõ°Ô∏è GOD MODE: OFF";
            }
        }

        function killAllEnemies() {
            enemies = [];
            bullets = [];
        }

        document.getElementById('start-hard-btn').addEventListener('click', showExpertSelect);
        document.getElementById('start-easy-btn').addEventListener('click', showRookieSelect);
        if (typeof THREE !== 'undefined') initThreeMenu();
        animateGame();
    </script>
</body>
</html>
