<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Void: BRIEFING UPDATE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #three-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        #gameCanvas {
            z-index: 1;
            opacity: 0;
            transition: opacity 1s;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }
        #boss-hud {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 1s;
        }
        #boss-name {
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: #ff4d4d;
            text-shadow: 0 0 10px #ff0000;
            margin-bottom: 5px;
        }
        
        /* NEW SHIELD BAR STYLES */
        #boss-shield-container {
            width: 60%;
            max-width: 600px;
            height: 6px;
            background: rgba(0, 50, 50, 0.3);
            border: 1px solid #00aaaa;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 4px; /* Space between shield and health */
            position: relative;
            display: none; /* Hidden by default until shield active */
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        #boss-shield-bar {
            width: 100%;
            height: 100%;
            background: #00ffff;
            box-shadow: 0 0 15px #00ffff;
            transition: width 0.1s;
        }

        #boss-health-container {
            width: 60%;
            max-width: 600px;
            height: 10px;
            background: rgba(50, 0, 0, 0.5);
            border: 1px solid #ff0000;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }
        #boss-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff8800);
            box-shadow: 0 0 15px #ff0000;
            transition: width 0.1s linear;
        }
        
        #player-hud {
            align-self: flex-start;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .hud-text {
            font-size: 18px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #menu-screen {
            pointer-events: auto;
            background: rgba(0,0,0,0.4);
            opacity: 0; /* Hidden initially, managed by JS */
        }
        #level-select-screen, #expert-level-select-screen, #hangar-screen, #intro-screen, #welcome-screen {
            pointer-events: auto;
            background: rgba(0,0,0,0.9);
            opacity: 0; /* Hidden by default */
            pointer-events: none;
        }
        #game-over-screen {
            background: rgba(0, 0, 0, 0.85);
            opacity: 0;
        }
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
        }
        .title-text {
            font-size: 64px;
            font-weight: 900;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 10px;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        .subtitle-text {
            font-size: 24px;
            color: #ccc;
            margin-bottom: 40px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .btn-container {
            display: flex;
            gap: 20px;
        }
        .btn {
            background: rgba(0, 0, 0, 0.6);
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 20px 40px;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            z-index: 30;
            position: relative;
        }
        .btn:hover {
            background: #00ffff;
            color: black;
            box-shadow: 0 0 40px #00ffff;
        }
        .btn-hard {
            border-color: #ff4444;
            color: #ff4444;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.2);
        }
        .btn-hard:hover {
            background: #ff4444;
            color: white;
            box-shadow: 0 0 40px #ff4444;
        }
        /* HANGAR BUTTON & SCREEN (REFINED) */
        .hangar-toggle-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            border: 2px solid #ffd700;
            color: #ffd700;
            background: rgba(0,0,0,0.6);
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: 0.3s;
        }
        .hangar-toggle-btn:hover {
            background: #ffd700;
            color: black;
            box-shadow: 0 0 20px #ffd700;
        }
        /* NEW HANGAR STYLES */
        #hangar-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Cyberpunk Panel Background */
            background: rgba(5, 10, 15, 0.95);
            /* Tech Grid Texture */
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            padding: 40px;
            border: 1px solid #00aaaa;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.15), inset 0 0 100px rgba(0,0,0,0.8);
            /* Sci-Fi Cut Corners */
            clip-path: polygon(
                0 0, 
                100% 0, 
                100% calc(100% - 30px), 
                calc(100% - 30px) 100%, 
                30px 100%, 
                0 calc(100% - 30px)
            );
            width: 85%;
            max-width: 900px;
            position: relative;
        }
        /* Decorative corner lines for hangar */
        #hangar-content::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: 1px solid transparent;
            pointer-events: none;
        }

        .hologram-container {
            position: relative;
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 240px;
            height: 240px;
            background: radial-gradient(circle, rgba(0, 50, 50, 0.4) 0%, rgba(0,0,0,0) 70%);
        }
        /* Corner Brackets for Hologram */
        .holo-bracket {
            position: absolute; width: 20px; height: 20px;
            border: 2px solid #00ffff;
            opacity: 0.8;
            transition: all 0.5s;
        }
        .hb-tl { top: 0; left: 0; border-right: 0; border-bottom: 0; }
        .hb-tr { top: 0; right: 0; border-left: 0; border-bottom: 0; }
        .hb-bl { bottom: 0; left: 0; border-right: 0; border-top: 0; }
        .hb-br { bottom: 0; right: 0; border-left: 0; border-top: 0; }
        
        /* Scanline Animation */
        .scanline {
            position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 10px #00ffff;
            animation: scan 3s linear infinite;
            pointer-events: none;
        }
        @keyframes scan { 0% { top: 0; opacity: 0; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { top: 100%; opacity: 0; } }

        .upgrade-row {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .upgrade-card {
            width: 220px;
            padding: 20px;
            background: rgba(20, 25, 30, 0.9);
            border: 1px solid #334;
            /* Top accent bar */
            border-top: 3px solid #444; 
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
            position: relative;
        }
        /* Type specific accents */
        .card-hp { border-top-color: #00ff00; }
        .card-cannon { border-top-color: #00ffff; }
        .card-special { border-top-color: #ff4444; }

        .upgrade-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            background: rgba(30, 35, 40, 0.95);
        }
        .card-hp:hover { border-color: #00ff00; box-shadow: 0 0 15px rgba(0, 255, 0, 0.2); }
        .card-cannon:hover { border-color: #00ffff; box-shadow: 0 0 15px rgba(0, 255, 255, 0.2); }
        .card-special:hover:not(.locked) { border-color: #ff4444; box-shadow: 0 0 15px rgba(255, 68, 68, 0.2); }

        .upgrade-title {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .upgrade-val {
            font-size: 14px; color: #fff; margin: 5px 0; font-weight: normal;
        }
        .highlight-val {
            font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 10px;
            text-shadow: 0 0 5px rgba(255,255,255,0.3);
        }

        /* Segmented Level Bar */
        .level-bar-container {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin: 15px 0;
        }
        .level-segment {
            width: 8px; height: 12px;
            background: #222;
            border: 1px solid #444;
            transform: skewX(-20deg);
            transition: all 0.3s;
        }
        /* Active colors for segments */
        .card-hp .level-segment.active { background: #00ff00; box-shadow: 0 0 5px #00ff00; border-color: #00ff00; }
        .card-cannon .level-segment.active { background: #00ffff; box-shadow: 0 0 5px #00ffff; border-color: #00ffff; }
        .card-special .level-segment.active { background: #ff4444; box-shadow: 0 0 5px #ff4444; border-color: #ff4444; }

        .locked { border-color: #333; color: #555; opacity: 0.6; pointer-events: none; border-top-color: #333; }
        .locked:hover { transform: none; box-shadow: none; border-color: #333; }
        
        /* LEVEL SELECT GRID */
        .level-grid {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 40px;
        }
        .level-btn {
            width: 100px;
            height: 100px;
            border-radius: 10%;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #444;
            color: #444;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer; 
            transition: all 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        .level-btn.active {
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.2);
            background: rgba(0, 50, 50, 0.6);
        }
        .level-btn.active:hover {
            background: #00ffff;
            color: black;
            box-shadow: 0 0 40px #00ffff;
            transform: scale(1.1);
        }
        .level-btn.locked {
            border-color: rgba(0, 255, 255, 0.3);
            color: rgba(0, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.7);
            font-size: 24px;
        }
        
        /* RED THEME FOR EXPERT */
        .red-theme .title-text { color: #ff4444 !important; text-shadow: 0 0 20px rgba(255, 0, 0, 0.5); }
        .red-theme .level-btn.active { border-color: #ff4444; color: #ff4444; background: rgba(50, 0, 0, 0.5); box-shadow: 0 0 15px rgba(255, 0, 0, 0.3); }
        .red-theme .level-btn.active:hover { background: #ff4444; color: black; box-shadow: 0 0 30px #ff4444; }
        .red-theme .level-btn.locked { border-color: rgba(255, 68, 68, 0.3); color: rgba(255, 68, 68, 0.3); }
        .red-theme .btn { border-color: #ff4444; color: #ff4444; }
        .red-theme .btn:hover { background: #ff4444; color: white; }

        /* INTRO / BRIEFING SCREEN - Reused for Welcome */
        .radio-box {
            width: 60%;
            max-width: 700px;
            background: rgba(0, 15, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 30px;
            font-family: 'Courier New', Courier, monospace;
            color: #00ff00;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.15);
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .radio-header {
            border-bottom: 1px solid #005500;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            justify-content: space-between;
        }
        .blink { animation: blink 1s infinite; }
        .radio-content {
            font-size: 20px;
            line-height: 1.6;
            margin-bottom: 30px;
            min-height: 100px;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }
        .radio-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
        }
        @keyframes blink { 50% { opacity: 0.3; } }

        /* CUSTOM MESSAGE MODAL */
        #msg-modal {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); border: 2px solid #ff4444;
            padding: 30px; z-index: 200; text-align: center; display: none;
            box-shadow: 0 0 30px rgba(255,0,0,0.3); pointer-events: auto;
        }
        #msg-text { font-size: 20px; color: white; margin-bottom: 20px; }

        /* Wave Announcement Text */
        #wave-announcement {
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 48px; font-weight: bold; color: #fff;
            text-shadow: 0 0 20px #00ffff; opacity: 0; pointer-events: none;
            transition: opacity 0.5s, transform 0.5s; transform: scale(0.5);
            letter-spacing: 10px; z-index: 15;
        }
        .phase-indicator {
            position: absolute; bottom: 20px; right: 20px;
            color: rgba(255, 255, 255, 0.3); font-size: 12px;
            font-family: monospace; text-align: right;
        }
        .controls-hint {
            margin-top: 20px; font-size: 14px;
            color: rgba(255,255,255,0.5); font-family: monospace;
        }

        /* DEV TOOLS */
        #dev-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 2000;
            background: rgba(0,0,0,0.7);
            border: 1px solid #ff00ff;
            color: #ff00ff;
            font-weight: bold;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
            pointer-events: auto;
        }
        #dev-panel {
            position: fixed;
            top: 40px;
            right: 10px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #ff00ff;
            padding: 15px;
            z-index: 2000;
            width: 220px;
            display: none;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.2);
            font-family: monospace;
            pointer-events: auto;
        }
        .dev-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .dev-input {
            width: 60px;
            background: #222;
            border: 1px solid #555;
            color: white;
            padding: 2px 5px;
        }
        .dev-btn {
            background: #333;
            color: #ff00ff;
            border: 1px solid #ff00ff;
            cursor: pointer;
            padding: 4px 10px;
            font-size: 12px;
            margin-bottom: 5px;
        }
        .dev-btn:hover { background: #ff00ff; color: black; }
    </style>
</head>
<body>

    <!-- 3D Background -->
    <div id="three-container"></div>
    <canvas id="gameCanvas"></canvas>

    <!-- White Flash Overlay -->
    <div id="flash-overlay"></div>

    <!-- DEV TOOLS UI -->
    <button id="dev-toggle" onclick="toggleDevPanel()">DEV</button>
    <div id="dev-panel">
        <div style="text-align: center; color: #ff00ff; margin-bottom: 10px; font-weight: bold;">DEV CONSOLE</div>
        
        <div class="dev-row">
            <span style="font-size: 12px; color: #ccc;">STARS:</span>
            <input type="number" id="dev-stars" class="dev-input" placeholder="Amount">
            <button class="dev-btn" onclick="devSetStars()">SET</button>
        </div>

        <div class="dev-row">
            <span style="font-size: 12px; color: #ccc;">WAVE:</span>
            <input type="number" id="dev-wave" class="dev-input" placeholder="#">
            <button class="dev-btn" onclick="devSkipWave()">GO</button>
        </div>

        <button class="dev-btn" style="width: 100%; color: #ff4444; border-color: #ff4444;" onclick="devKillAll()">KILL ALL ENEMIES</button>
        
        <div style="margin-top: 10px; border-top: 1px solid #555; padding-top: 10px; text-align: center;">
            <span style="font-size: 11px; color: #aaa; display: block; margin-bottom: 5px;">DATA MANAGEMENT</span>
            <button class="dev-btn" style="width: 100%; color: #00ff00; border-color: #00ff00;" onclick="devUnlockStages()">UNLOCK ALL STAGES</button>
            <button class="dev-btn" style="width: 100%; color: #ffd700; border-color: #ffd700;" onclick="devResetStarsOnly()">RESET STARS</button>
            <button class="dev-btn" style="width: 100%; color: #00ffff; border-color: #00ffff;" onclick="devResetUpgradesOnly()">RESET UPGRADES</button>
            <button class="dev-btn" style="width: 100%; color: #ff00ff; border-color: #ff00ff;" onclick="devResetLevelsOnly()">RESET LEVELS</button>
            <button class="dev-btn" style="width: 100%; color: #ff3300; border-color: #ff3300; font-weight: bold; background: #300;" onclick="devGlobalWipe()">GLOBAL DATA WIPE</button>
            <button class="dev-btn" style="width: 100%; color: #888; border-color: #888;" onclick="devResetCookies()">CLEAR COOKIES (INTRO)</button>
        </div>
    </div>

    <!-- Message Modal -->
    <div id="msg-modal">
        <div class="title-text" style="font-size: 30px; margin-bottom: 10px; color: #ff4444;">ACCESS DENIED</div>
        <div id="msg-text">Level Locked. Complete previous sector.</div>
        <button class="btn" onclick="closeMsgModal()" style="font-size: 16px; padding: 10px 30px;">OK</button>
    </div>

    <div id="ui-layer">
        <div id="boss-hud">
            <div id="boss-name">System Core: Omega</div>
            <!-- SEPARATE SHIELD CONTAINER -->
            <div id="boss-shield-container">
                <div id="boss-shield-bar"></div>
            </div>
            <!-- HEALTH CONTAINER -->
            <div id="boss-health-container">
                <div id="boss-health-bar"></div>
            </div>
        </div>
        <div id="player-hud">
            <div class="hud-text">HP: <span id="player-hp">100</span>%</div>
            <div class="hud-text">SCORE: <span id="score">0</span></div>
            <div class="hud-text" style="color: #ffd700;">STARS: <span id="stars-display">0</span></div>
            <div class="hud-text" style="font-size: 14px; margin-top: 5px; color: #aaa;">STAGE: <span id="stage-display">1</span></div>
        </div>
        <div class="phase-indicator" id="phase-debug">INIT</div>
        <div id="wave-announcement">WAVE 1</div>
    </div>

    <!-- NEW: WELCOME / COOKIE SCREEN -->
    <div id="welcome-screen" class="screen-overlay">
        <div class="radio-box" id="welcome-box">
            <div class="radio-header">
                <span id="welcome-header">UNIDENTIFIED SIGNAL</span>
                <span class="blink">‚óè LIVE</span>
            </div>
            <div id="welcome-content" class="radio-content">
                <!-- Dynamic Content -->
            </div>
            <div class="radio-footer" id="welcome-footer">
                <!-- Dynamic Buttons -->
            </div>
        </div>
    </div>

    <!-- INTRO / BRIEFING SCREEN -->
    <div id="intro-screen" class="screen-overlay">
        <div class="radio-box">
            <div class="radio-header">
                <span>INCOMING TRANSMISSION</span>
                <span class="blink">‚óè REC</span>
            </div>
            <div id="radio-content" class="radio-content">
                <!-- Text goes here -->
            </div>
            <div class="radio-footer">
                <button class="btn" style="border-color: #00ff00; color: #00ff00; font-family: inherit;" onclick="skipIntro()">ESTABLISH LINK (SKIP) <span id="intro-countdown">30</span>s</button>
            </div>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="menu-screen" class="screen-overlay">
        <div class="title-text" style="color: #00ffff;">NEON VOID</div>
        <div class="subtitle-text">SELECT DIFFICULTY</div>
        <div class="btn-container">
            <button id="start-hard-btn" class="btn btn-hard">EXPERT</button>
            <button id="start-easy-btn" class="btn">BEGINNER</button>
        </div>
        <div class="controls-hint">ARROWS / WASD to Move &nbsp;|&nbsp; MOUSE to Follow</div>
    </div>

    <!-- ROOKIE LEVEL SELECT -->
    <div id="level-select-screen" class="screen-overlay">
        <button class="hangar-toggle-btn" onclick="openHangar('easy')">üõ†Ô∏è HANGAR</button>
        <div class="title-text" style="color: #00ffff;">BEGINNER CAMPAIGN</div>
        <div id="easy-grid" class="level-grid">
            <!-- JS GENERATED -->
        </div>
        <button class="btn" onclick="resetToMenu()">BACK</button>
    </div>

    <!-- EXPERT LEVEL SELECT -->
    <div id="expert-level-select-screen" class="screen-overlay red-theme">
        <button class="hangar-toggle-btn" onclick="openHangar('hard')">üõ†Ô∏è HANGAR</button>
        <div class="title-text">EXPERT CAMPAIGN</div>
        <div id="hard-grid" class="level-grid">
            <!-- JS GENERATED -->
        </div>
        <button class="btn" onclick="resetToMenu()">BACK</button>
    </div>

    <!-- HANGAR SCREEN (REFINED) -->
    <div id="hangar-screen" class="screen-overlay">
        <div id="hangar-content">
            <div class="title-text" id="hangar-title" style="font-size: 36px; margin-bottom: 10px; color: #fff; text-shadow: 0 0 20px #00ffff;">HANGAR</div>
            <div style="font-size: 20px; color: #ffd700; margin-bottom: 30px; font-weight: bold; text-shadow: 0 0 10px #ffd700; letter-spacing: 2px;">CREDITS: <span id="hangar-stars">0</span> ‚≠ê</div>
            
            <!-- Ship Preview Hologram -->
            <div class="hologram-container">
                <div class="holo-bracket hb-tl"></div>
                <div class="holo-bracket hb-tr"></div>
                <div class="holo-bracket hb-bl"></div>
                <div class="holo-bracket hb-br"></div>
                <div class="scanline"></div>
                <canvas id="hangarShipCanvas" width="200" height="200" style="z-index: 2;"></canvas>
            </div>
    
            <div class="upgrade-row">
                <!-- HP CARD -->
                <div class="upgrade-card card-hp">
                    <div class="upgrade-title">HULL INTEGRITY</div>
                    <div class="level-bar-container" id="hp-bar-container">
                        <div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div>
                    </div>
                    <div class="highlight-val" id="hp-bonus" style="color: #0f0;">+0 HP</div>
                    <button id="btn-upg-hp" class="btn" style="font-size: 14px; padding: 10px; width: 100%; border-color: #0f0; color: #0f0;" onclick="upgradeHealth()">UPGRADE</button>
                </div>

                <!-- CANNON CARD -->
                <div class="upgrade-card card-cannon">
                    <div class="upgrade-title">MAIN CANNON</div>
                    <div class="level-bar-container" id="cannon-bar-container">
                        <div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div>
                    </div>
                    <div class="highlight-val" id="cannon-bonus" style="color: #00ffff;">+0 DMG</div>
                    <button id="btn-upg-cannon" class="btn" style="font-size: 14px; padding: 10px; width: 100%; border-color: #00ffff; color: #00ffff;" onclick="upgradeCannon()">UPGRADE</button>
                </div>

                <!-- SPECIAL CARD (LOCKED) -->
                <div class="upgrade-card card-special locked">
                    <div class="upgrade-title">HEAVY BEAM</div>
                    <div class="level-bar-container">
                        <div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div><div class="level-segment"></div>
                    </div>
                    <div class="highlight-val" style="color: #555;">LOCKED</div>
                    <button class="btn" style="font-size: 14px; padding: 10px; width: 100%; background: #111; border-color: #333; cursor: not-allowed; color: #555;">REQ. LVL 5</button>
                </div>
            </div>
            <button class="btn" style="margin-top: 10px; border-color: #fff; color: #fff;" onclick="closeHangar()">EXIT HANGAR</button>
        </div>
    </div>

    <div id="game-over-screen" class="screen-overlay">
        <div class="title-text" id="game-over-title">Mission Failed</div>
        <button id="retry-btn" class="btn" onclick="resetToMenu()">Main Menu</button>
    </div>

    <script>
        const STATE = { 
            WELCOME: 'welcome',
            MENU: 'menu', 
            LEVEL_SELECT: 'level_select', 
            INTRO: 'intro',
            PLAYING: 'playing', 
            GAMEOVER: 'gameover', 
            VICTORY_SEQUENCE: 'victory_sequence',
            HANGAR: 'hangar'
        };
        let gameState = STATE.MENU;
        let width, height;
        let currentLevelIndex = 1;
        let activeDifficultyMode = 'easy'; // 'easy' or 'hard'
        let currentHangarMode = 'easy'; // Tracks which hangar is open
        let introTimer = 30;
        let introInterval = null;
        let cookiesAccepted = false; // Flag to track user consent

        // --- STAGE MESSAGES ---
        const STAGE_MESSAGES = {
            'easy_1': "Pilot, we have lost contact with Outpost Omega. Sensors indicate the System Core has gone rogue. <br><br>Neutralize the threat before it spreads to the network.",
            'easy_2': "Warning! Massive energy signature detected. It's the Terminator class dreadnought. <br><br> This won't be like the simulations. Stay sharp.",
            'easy_3': "Entering deep sector. Signal interference high. \n\nThe core fragments have re-assembled. Expect heavy resistance.",
            'hard_1': "Veteran difficulty authorized. <br><br>The enemy AI has adapted to standard tactics. Expect aggressive maneuvers.",
            'hard_2': "This is it. The Elite Terminator unit has been deployed. <br><br>Survival probability is near zero. Good luck, Commander.",
            'hard_3': "Elite Deep Sector. \n\nNo support available. You are on your own, Commander."
        };

        // --- STORAGE HELPER FUNCTIONS (Switched to LocalStorage for reliability) ---
        // Note: Real cookies often fail in iframe/preview sandboxes. 
        // We use LocalStorage here to ensure your save works, but keep the "Cookie" UI theme.
        
        function setCookie(name, value, days) {
            // Using LocalStorage to mimic cookie behavior for reliability
            localStorage.setItem(name, value);
        }

        function getCookie(name) {
            return localStorage.getItem(name);
        }

        function deleteCookie(name) {
            localStorage.removeItem(name);
        }

        // --- DATA PERSISTENCE ---
        let gameData;
        
        function initData() {
            const cookieData = getCookie('neonVoidData_v3');
            if (cookieData) {
                try {
                    gameData = JSON.parse(cookieData);
                } catch (e) {
                    console.error("Corrupt game data, resetting.");
                    gameData = null;
                }
            }

            if (!gameData) {
                // Default initial state
                gameData = {
                    easy: { stars: 0, healthLvl: 0, cannonLvl: 0, maxStage: 1 },
                    hard: { stars: 0, healthLvl: 0, cannonLvl: 0, maxStage: 1 }
                };
            }
            // Ensure new properties exist for old saves
            if (gameData.easy.cannonLvl === undefined) gameData.easy.cannonLvl = 0;
            if (gameData.hard.cannonLvl === undefined) gameData.hard.cannonLvl = 0;
        }

        function saveData() {
            if (!cookiesAccepted) return; // DON'T SAVE IF COOKIES DENIED
            setCookie('neonVoidData_v3', JSON.stringify(gameData), 365);
        }

        // --- UPGRADE CONFIGURATION ---
        const HEALTH_UPGRADES = {
            costs: [110, 150, 200, 600, 1100], 
            bonuses: [5, 10, 15, 20, 50]       
        };

        const CANNON_UPGRADES = {
            costs: [150, 200, 500, 1000, 10000],
            bonuses: [1, 2, 3, 4, 5] 
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const flashOverlay = document.getElementById('flash-overlay');
        const menuScreen = document.getElementById('menu-screen');
        const levelSelectScreen = document.getElementById('level-select-screen');
        const expertSelectScreen = document.getElementById('expert-level-select-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const hangarScreen = document.getElementById('hangar-screen');
        const introScreen = document.getElementById('intro-screen');
        const welcomeScreen = document.getElementById('welcome-screen');
        const msgModal = document.getElementById('msg-modal');
        
        function resizeGame() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resizeGame();
        window.addEventListener('resize', resizeGame);

        // UI
        const bossHud = document.getElementById('boss-hud');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossShieldContainer = document.getElementById('boss-shield-container');
        const bossShieldBar = document.getElementById('boss-shield-bar');
        const bossName = document.getElementById('boss-name');
        const playerHud = document.getElementById('player-hud');
        const playerHpEl = document.getElementById('player-hp');
        const scoreEl = document.getElementById('score');
        const starsDisplayEl = document.getElementById('stars-display');
        const stageDisplayEl = document.getElementById('stage-display');
        const gameOverTitle = document.getElementById('game-over-title');
        const phaseDebug = document.getElementById('phase-debug');
        const waveText = document.getElementById('wave-announcement');

        // Input
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, s: false, a: false, d: false
        };
        const mouse = { x: width / 2, y: height - 150, down: false, targetX: width / 2, targetY: height - 150 };
        let isTouch = false;

        /**
         * THREE.JS BACKGROUND & EFFECTS
         */
        let scene, camera, renderer;
        let menuCore, stars, bossPhase2Mesh, bossShieldMesh;
        let isPhase2Active = false;
        let supernovaMesh, supernovaParticles;
        let supernovaVelocities = [];
        let isSupernovaExploding = false;

        // 3D GLITCH ASSETS (Stage 3)
        let glitchBossMesh;

        // 2D DROPS
        let dropMeshes = []; 

        function initThreeMenu() {
            if (typeof THREE === 'undefined') return;

            try {
                const container = document.getElementById('three-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x050505, 0.002);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 50;

                renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.domElement.id = 'menuCanvas';
                container.appendChild(renderer.domElement);

                // 1. Menu Core
                const geometry = new THREE.IcosahedronGeometry(10, 1);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.8 });
                menuCore = new THREE.Mesh(geometry, material);
                scene.add(menuCore);

                // 2. Stars
                const starGeo = new THREE.BufferGeometry();
                const starCount = 2000;
                const posArray = new Float32Array(starCount * 3);
                for(let i=0; i<starCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 400;
                starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const starMat = new THREE.PointsMaterial({ size: 0.5, color: 0xffffff });
                stars = new THREE.Points(starGeo, starMat);
                scene.add(stars);

                // 3. PHASE 2 BOSS MESH (System Core)
                const bossGeo = new THREE.TorusKnotGeometry(12, 3, 100, 16);
                const bossMat = new THREE.MeshBasicMaterial({ color: 0xff3300, wireframe: true });
                bossPhase2Mesh = new THREE.Mesh(bossGeo, bossMat);
                bossPhase2Mesh.visible = false;
                bossPhase2Mesh.position.z = -20;
                scene.add(bossPhase2Mesh);
                
                const ringGeo = new THREE.RingGeometry(20, 22, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                bossPhase2Mesh.add(ring);

                // 4. BOSS SHIELD (UPDATED to Sphere surface, transparent)
                // Radius reduced to 16 to prevent clipping when boss scales up
                const shieldGeo = new THREE.SphereGeometry(16, 32, 32);
                const shieldMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    wireframe: false, 
                    transparent: true, 
                    opacity: 0.4,     
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending // Glowy effect
                });
                bossShieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
                bossShieldMesh.visible = false;
                bossPhase2Mesh.add(bossShieldMesh); 

                // 5. GLITCH BOSS MESH (Octahedron)
                const glitchGeo = new THREE.OctahedronGeometry(15, 0);
                const glitchMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff00ff, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                glitchBossMesh = new THREE.Mesh(glitchGeo, glitchMat);
                glitchBossMesh.visible = false;
                glitchBossMesh.position.z = -20;
                scene.add(glitchBossMesh);

                // 6. SUPERNOVA ASSETS
                const snGeo = new THREE.SphereGeometry(1, 32, 32);
                const snMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0, wireframe: true });
                supernovaMesh = new THREE.Mesh(snGeo, snMat);
                supernovaMesh.visible = false;
                scene.add(supernovaMesh);

                const pGeo = new THREE.BufferGeometry();
                const pCount = 500; // REDUCED FROM 2000
                const pPos = new Float32Array(pCount * 3);
                supernovaVelocities = [];
                for(let i=0; i<pCount; i++) {
                    pPos[i*3] = 0; pPos[i*3+1] = 0; pPos[i*3+2] = 0;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const speed = 2 + Math.random() * 4;
                    supernovaVelocities.push(
                        Math.sin(phi) * Math.cos(theta) * speed,
                        Math.sin(phi) * Math.sin(theta) * speed,
                        Math.cos(phi) * speed
                    );
                }
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const pMat = new THREE.PointsMaterial({ color: 0xff5500, size: 0.8, transparent: true });
                supernovaParticles = new THREE.Points(pGeo, pMat);
                supernovaParticles.visible = false;
                scene.add(supernovaParticles);

                animateThree();
            } catch (e) { console.warn("Error initializing 3D:", e); }
        }

        function triggerSupernova() {
            if(!supernovaMesh || !supernovaParticles) return;
            isSupernovaExploding = true;
            
            let posToCopy = {x:0, y:20, z:-20};

            if(boss && boss.isGlitch && glitchBossMesh) {
                posToCopy.x = (boss.x / width) * 120 - 60;
                posToCopy.y = (boss.y / height) * -60 + 30; // Approx
            }
            else if(bossPhase2Mesh && isPhase2Active) {
                posToCopy = bossPhase2Mesh.position;
            } 

            supernovaMesh.position.copy(posToCopy);
            supernovaParticles.position.copy(posToCopy);

            if(bossPhase2Mesh) bossPhase2Mesh.visible = false;
            if(glitchBossMesh) glitchBossMesh.visible = false;
            
            supernovaMesh.scale.set(1,1,1);
            supernovaMesh.material.opacity = 1;
            supernovaMesh.visible = true;

            const positions = supernovaParticles.geometry.attributes.position.array;
            positions.fill(0);
            supernovaParticles.geometry.attributes.position.needsUpdate = true;
            supernovaParticles.material.opacity = 1;
            supernovaParticles.visible = true;
        }

        function animateThree() {
            requestAnimationFrame(animateThree);
            
            // SHOW CORE IN MENU OR LEVEL SELECT OR HANGAR OR INTRO
            if ((gameState === STATE.MENU || gameState === STATE.LEVEL_SELECT || gameState === STATE.HANGAR || gameState === STATE.INTRO || gameState === STATE.WELCOME) && menuCore) {
                menuCore.rotation.x += 0.005; menuCore.rotation.y += 0.01; menuCore.visible = true;
                if(glitchBossMesh) glitchBossMesh.visible = false;
            } else if (menuCore) { menuCore.visible = false; }

            // GLITCH BOSS UPDATE
            if (boss && boss.active && boss.isGlitch && glitchBossMesh && !isSupernovaExploding) {
                glitchBossMesh.visible = true;
                glitchBossMesh.rotation.y += 0.05;
                glitchBossMesh.rotation.z += 0.02;
                
                // Jitter effect
                const jitter = (Math.random() - 0.5) * 0.5;
                glitchBossMesh.scale.set(1 + jitter, 1 + jitter, 1 + jitter);
                
                // Position Sync (Approximate mapping from 2D canvas to 3D world)
                let targetX = (boss.x / width) * 120 - 60;
                let targetY = -(boss.y / height) * 60 + 30;
                
                // Instant teleport for glitch feel
                glitchBossMesh.position.x = targetX;
                glitchBossMesh.position.y = targetY;
                
                // Color Pulse
                const hue = (Date.now() % 2000) / 2000;
                glitchBossMesh.material.color.setHSL(hue, 1, 0.5);

            } else if (glitchBossMesh) {
                glitchBossMesh.visible = false;
            }

            // BOSS UPDATES (Original Boss)
            if (isPhase2Active && bossPhase2Mesh && !isSupernovaExploding && (!boss || !boss.isGlitch)) {
                bossPhase2Mesh.visible = true;
                bossPhase2Mesh.rotation.x += 0.02; bossPhase2Mesh.rotation.y += 0.03;
                
                let targetX = 0;
                if (boss) {
                    targetX = (boss.x / width) * 120 - 60;
                    
                    if (bossShieldMesh) {
                        bossShieldMesh.visible = (boss.shieldHp > 0);
                        // Rotate Shield
                        bossShieldMesh.rotation.y -= 0.02;
                        // Pulse Shield Scale
                        const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.05;
                        bossShieldMesh.scale.set(pulse, pulse, pulse);
                    }
                }

                const baseScale = 4 + Math.sin(Date.now() * 0.01) * 0.5; 
                bossPhase2Mesh.scale.set(baseScale, baseScale, baseScale);
                bossPhase2Mesh.position.x += (targetX - bossPhase2Mesh.position.x) * 0.2;
                bossPhase2Mesh.position.y += (0 - bossPhase2Mesh.position.y) * 0.2;
                if(bossPhase2Mesh.material) bossPhase2Mesh.material.color.setHex(0xff3300);
                bossPhase2Mesh.rotation.z = 0;
            } else if (bossPhase2Mesh && !isSupernovaExploding) { bossPhase2Mesh.visible = false; }

            if (isSupernovaExploding) {
                const scale = supernovaMesh.scale.x + 3;
                supernovaMesh.scale.set(scale, scale, scale);
                supernovaMesh.rotation.y += 0.1;
                supernovaMesh.material.opacity -= 0.015;

                const positions = supernovaParticles.geometry.attributes.position.array;
                for(let i=0; i<supernovaVelocities.length/3; i++) {
                    positions[i*3] += supernovaVelocities[i*3];
                    positions[i*3+1] += supernovaVelocities[i*3+1];
                    positions[i*3+2] += supernovaVelocities[i*3+2];
                }
                supernovaParticles.geometry.attributes.position.needsUpdate = true;
                supernovaParticles.material.opacity -= 0.01;

                if (supernovaMesh.material.opacity <= 0) {
                    isSupernovaExploding = false;
                    supernovaMesh.visible = false;
                    supernovaParticles.visible = false;
                }
            }

            if (stars) { stars.rotation.y += 0.0005; stars.rotation.x += 0.0002; }
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // --- UPDATED INPUT HANDLING ---
        window.addEventListener('keydown', e => {
            if (gameState === STATE.PLAYING) {
                const k = e.key.toLowerCase();
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true; 
                if (keys.hasOwnProperty(k)) keys[k] = true;
                if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].indexOf(e.code) > -1) {
                    e.preventDefault();
                }
            }
        });

        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
            if (keys.hasOwnProperty(k)) keys[k] = false;
        });

        function updateInput(e) {
            if (gameState === STATE.PLAYING) e.preventDefault();
            let cx, cy;
            if (e.touches && e.touches.length > 0) {
                isTouch = true; cx = e.touches[0].clientX; cy = e.touches[0].clientY; mouse.down = true;
            } else {
                isTouch = false; cx = e.clientX; cy = e.clientY; mouse.down = e.buttons === 1;
            }
            mouse.targetX = cx; mouse.targetY = isTouch ? cy - 80 : cy;
        }
        window.addEventListener('mousemove', updateInput);
        window.addEventListener('mousedown', updateInput);
        window.addEventListener('mouseup', () => mouse.down = false);
        window.addEventListener('touchstart', updateInput, {passive: false});
        window.addEventListener('touchmove', updateInput, {passive: false});
        window.addEventListener('touchend', () => mouse.down = false);

        /**
         * GAME LOGIC
         */
        const ATTACK_SEQUENCE = ['laser', 'swarm', 'missiles', 'laser', 'laser', 'redLines', 'missiles', 'rings', 'laser', 'laser', 'swarm'];
        const TERMINATOR_SEQUENCE = ['terminator_fireballs', 'terminator_rapid', 'terminator_laser'];
        const GLITCH_SEQUENCE = ['glitch_teleport_rapid', 'glitch_grid', 'glitch_clones', 'glitch_grid', 'glitch_teleport_fire'];

        // --- DIFFICULTY SETTINGS ---
        const DIFFICULTY = {
            NORMAL: {
                name: "VETERAN",
                playerDamage: 5,
                swarmHp: 20,
                heavyHp: 80,
                laserHp: 60,
                bossHp: 5000,
                heavyAgile: true,
                enemyCountMult: 1.0, 
                fireRateMult: 1.0, 
                waveDelay: 60
            },
            EASY: {
                name: "ROOKIE",
                playerDamage: 10,
                swarmHp: 10,
                heavyHp: 40,
                laserHp: 30,
                bossHp: 2500, 
                heavyAgile: false,
                enemyCountMult: 0.5, 
                fireRateMult: 1.5, 
                waveDelay: 120
            }
        };
        let currentSettings = DIFFICULTY.NORMAL;

        class Particle {
            constructor(x, y, color, speed, size, life) {
                this.x = x; this.y = y; this.color = color;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = Math.random() * speed;
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.life = life; this.maxLife = life; this.size = size;
                this.decay = Math.random() * 0.05 + 0.92;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vx *= this.decay; this.vy *= this.decay;
                this.life--; this.size *= 0.95;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(0.1, this.size), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class Drop {
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.type = type; // 'star' or 'health'
                this.active = true;
                this.rot = 0;
            }
            update() {
                this.y += 1.0; 
                this.rot += 0.05;
                if (this.y > height + 20) this.active = false;

                if (player && player.active) {
                    let dist = Math.hypot(this.x - player.x, this.y - player.y);
                    if (dist < 40) this.collect();
                }
            }
            collect() {
                this.active = false;
                
                if (this.type === 'star') {
                    if (activeDifficultyMode === 'easy') gameData.easy.stars++;
                    else gameData.hard.stars++;
                    saveData();
                    updateUI();
                    for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, '#ffd700', 3, 2, 20));
                } else if (this.type === 'health') {
                    if (player.hp < player.maxHp) {
                        const healAmount = player.maxHp * 0.1;
                        player.hp = Math.min(player.maxHp, player.hp + healAmount);
                        playerHpEl.innerText = Math.floor(player.hp);
                        for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#00ffff', 4, 3, 30));
                    }
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rot);
                
                if (this.type === 'star') {
                    ctx.fillStyle = '#ffd700'; ctx.shadowBlur = 15; ctx.shadowColor = '#ffd700';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * 10, -Math.sin((18 + i * 72) * Math.PI / 180) * 10);
                        ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * 4, -Math.sin((54 + i * 72) * Math.PI / 180) * 4);
                    }
                    ctx.closePath(); ctx.fill();
                } else {
                    ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(0, 50, 50, 0.8)';
                    ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
                    ctx.fillRect(-8, -8, 16, 16); ctx.strokeRect(-8, -8, 16, 16);
                    ctx.fillStyle = '#00ffff'; ctx.fillRect(-2, -5, 4, 10); ctx.fillRect(-5, -2, 10, 4);
                }
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, vx, vy, type, damage) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.type = type; this.active = true;
                if (type === 'player') {
                    this.color = '#00ffff'; this.size = 3; 
                    this.damage = damage || currentSettings.playerDamage; 
                } else if (type === 'boss_orb') {
                    this.color = '#ffaa00'; this.size = 6; this.damage = 10;
                } else if (type === 'fireball') {
                    this.color = '#ff4400'; this.size = 12; this.damage = 15;
                } else if (type === 'saw') {
                    this.color = '#cccccc'; this.size = 15; this.damage = 15;
                } else if (type === 'boss_laser_bit') {
                    this.color = '#ff0055'; this.size = 4; this.damage = 15;
                } else if (type === 'missile') {
                    this.color = '#ff0000'; this.size = 5; this.damage = 20;
                    this.angle = Math.atan2(vy, vx); this.speed = 4;
                    this.guidanceTimer = 90; 
                } else if (type === 'glitch_laser') {
                    this.color = '#ff00ff'; this.size = 2000; this.damage = 25; // Size is length
                    this.isVertical = vx === 0;
                    this.warmup = 60; // 1 second warning
                    this.life = 80;
                }
            }
            update() {
                if (this.type === 'glitch_laser') {
                    this.warmup--;
                    this.life--;
                    if(this.life <= 0) this.active = false;
                    return; // Stationary
                }
                if (this.type === 'missile' && player.active && this.guidanceTimer > 0) {
                    let dx = player.x - this.x; let dy = player.y - this.y;
                    let targetAngle = Math.atan2(dy, dx);
                    let diff = targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.05;
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                    this.guidanceTimer--;
                    if (Math.random() > 0.5) particles.push(new Particle(this.x, this.y, '#555', 1, 3, 20));
                }
                if (this.type === 'fireball') {
                      particles.push(new Particle(this.x, this.y, '#ffaa00', 1, 4, 10));
                }
                this.x += this.vx; this.y += this.vy;
                if (this.x < -100 || this.x > width + 100 || this.y < -100 || this.y > height + 100) this.active = false;
            }
            draw() {
                if (this.type === 'glitch_laser') {
                     ctx.save();
                     // Warning Phase
                     if(this.warmup > 0) {
                         ctx.strokeStyle = `rgba(255, 0, 255, ${0.5 + Math.sin(frames*0.5)*0.5})`;
                         ctx.lineWidth = 2;
                         ctx.setLineDash([5, 5]);
                     } else {
                         // Active Phase
                         ctx.strokeStyle = '#ff00ff';
                         ctx.lineWidth = 10 + Math.random()*5; // Glitch width
                         ctx.shadowBlur = 20; ctx.shadowColor = '#ff00ff';
                         ctx.setLineDash([]);
                     }

                     ctx.beginPath();
                     if(this.isVertical) {
                         ctx.moveTo(this.x, 0); ctx.lineTo(this.x, height);
                     } else {
                         ctx.moveTo(0, this.y); ctx.lineTo(width, this.y);
                     }
                     ctx.stroke();
                     ctx.restore();
                     return;
                }

                ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fillStyle = this.color;
                if (this.type === 'missile') {
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                    ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill();
                    ctx.restore();
                } else if (this.type === 'saw') {
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(frames * 0.5); 
                    ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = "#888"; for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.fillRect(12, -4, 8, 8); }
                    ctx.fillStyle = "#ff0000"; ctx.beginPath(); ctx.arc(0,0, 5, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                } else {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
        }

        class Player {
            constructor() {
                this.x = width / 2; this.y = height - 100;
                this.active = true; this.iframes = 0; this.speed = 8;
                let baseHp = 100;
                let bonusHp = 0;
                const stats = gameData[activeDifficultyMode]; 
                
                // HP Calculation
                const hpLevel = stats.healthLvl;
                for(let i=0; i < hpLevel; i++) { bonusHp += HEALTH_UPGRADES.bonuses[i]; }
                this.maxHp = baseHp + bonusHp;
                this.hp = this.maxHp;
                playerHpEl.innerText = Math.floor(this.hp);

                // Damage Calculation
                let bonusDamage = 0;
                const cannonLevel = stats.cannonLvl;
                for(let i=0; i < cannonLevel; i++) { bonusDamage += CANNON_UPGRADES.bonuses[i]; }
                this.damage = currentSettings.playerDamage + bonusDamage;
            }
            update() {
                if (!this.active) return;
                if (gameState === STATE.PLAYING) {
                    let dx = 0, dy = 0;
                    if (keys.ArrowUp || keys.w) dy -= this.speed;
                    if (keys.ArrowDown || keys.s) dy += this.speed;
                    if (keys.ArrowLeft || keys.a) dx -= this.speed;
                    if (keys.ArrowRight || keys.d) dx += this.speed;
                    if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
                    if (dx !== 0 || dy !== 0) {
                        this.x += dx; this.y += dy;
                        mouse.targetX = this.x; mouse.targetY = this.y;
                    } else if (mouse.targetX !== undefined) {
                        this.x += (mouse.targetX - this.x) * 0.15;
                        this.y += (mouse.targetY - this.y) * 0.15;
                    }
                    this.x = Math.max(20, Math.min(width - 20, this.x));
                    this.y = Math.max(20, Math.min(height - 20, this.y));

                    if (frames % 6 === 0) {
                        bullets.push(new Bullet(this.x - 10, this.y - 10, 0, -15, 'player', this.damage));
                        bullets.push(new Bullet(this.x + 10, this.y - 10, 0, -15, 'player', this.damage));
                    }
                }
                if (this.iframes > 0) this.iframes--;
                particles.push(new Particle(this.x, this.y + 15, '#00ffff', 2, 4, 10));
            }
            draw() {
                if (!this.active && gameState !== STATE.VICTORY_SEQUENCE) return;
                
                if (this.iframes > 0 && Math.floor(frames / 4) % 2 === 0) return;
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.shadowBlur = 20; ctx.shadowColor = '#00ffff'; ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(15, 15); ctx.lineTo(0, 10); ctx.lineTo(-15, 15); ctx.fill();
                ctx.fillStyle = '#00aaaa';
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(20, 10); ctx.lineTo(20, 25); ctx.lineTo(5, 15); ctx.fill();
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-20, 10); ctx.lineTo(-20, 25); ctx.lineTo(-5, 15); ctx.fill();
                ctx.restore(); ctx.shadowBlur = 0;
            }
            hit(damage) {
                if (this.iframes > 0 || !this.active) return;
                this.hp -= damage; this.iframes = 30;
                playerHpEl.innerText = Math.max(0, Math.floor(this.hp));
                ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);
                setTimeout(() => ctx.setTransform(1,0,0,1,0,0), 50);
                if (this.hp <= 0) {
                    this.active = false;
                    for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, '#00ffff', 5, 5, 60));
                    gameOver(false);
                }
            }
        }

        class SwarmEnemy {
            constructor(x, y) {
                this.x = x; this.y = y; this.origX = x; this.origY = y;
                this.active = true; 
                this.hp = currentSettings.swarmHp;
                this.timeOffset = Math.random() * 100;
                this.fireTimer = (Math.random() * 120 + 60) * currentSettings.fireRateMult; 
                this.points = 100;
            }
            update() {
                if (!this.active) return;
                this.x = this.origX + Math.sin((frames + this.timeOffset) * 0.05) * 50;
                this.y += 1.5;
                this.fireTimer--;
                if (this.fireTimer <= 0) {
                    let angle = Math.atan2(player.y - this.y, player.x - this.x);
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*4, Math.sin(angle)*4, 'boss_orb'));
                    this.fireTimer = (120 + Math.random() * 60) * currentSettings.fireRateMult;
                }
                if (this.y > height + 20) this.active = false;
            }
            draw() {
                if (!this.active) return;
                ctx.fillStyle = '#aa00aa'; ctx.shadowBlur = 5; ctx.shadowColor = '#ff00ff';
                ctx.beginPath(); ctx.moveTo(this.x, this.y - 10); ctx.lineTo(this.x + 10, this.y);
                ctx.lineTo(this.x, this.y + 10); ctx.lineTo(this.x - 10, this.y); ctx.fill();
                ctx.shadowBlur = 0;
            }
            hit(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.active = false; score += this.points; scoreEl.innerText = score;
                    for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, '#ff00ff', 3, 3, 30));
                    drops.push(new Drop(this.x, this.y, 'star'));
                }
            }
        }

        class HeavyStriker {
            constructor(x, y) {
                this.x = x; this.y = y; this.vx = (Math.random() < 0.5 ? -1 : 1) * 2;
                this.active = true; 
                this.hp = currentSettings.heavyHp;
                this.fireTimer = (Math.random() * 60 + 60) * currentSettings.fireRateMult;
                this.points = 300;
            }
            update() {
                if(!this.active) return;
                this.y += 1.0; 
                if (currentSettings.heavyAgile) {
                    this.x += this.vx;
                    if (this.x < 50 || this.x > width - 50) this.vx *= -1;
                }
                this.fireTimer--;
                if(this.fireTimer <= 0) {
                    let angle = Math.atan2(player.y - this.y, player.x - this.x);
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*4, Math.sin(angle)*4, 'boss_orb'));
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle-0.3)*4, Math.sin(angle-0.3)*4, 'boss_orb'));
                    bullets.push(new Bullet(this.x, this.y, Math.cos(angle+0.3)*4, Math.sin(angle+0.3)*4, 'boss_orb'));
                    this.fireTimer = 100 * currentSettings.fireRateMult; 
                }
                if(this.y > height + 50) this.active = false;
            }
            draw() {
                if(!this.active) return;
                ctx.fillStyle = '#ff4400';
                ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 20);
                ctx.lineTo(this.x + 20, this.y - 10);
                ctx.lineTo(this.x - 20, this.y - 10);
                ctx.fill();
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(this.x - 5, this.y - 5, 10, 10);
                ctx.shadowBlur = 0;
            }
            hit(damage) {
                this.hp -= damage;
                if(this.hp <= 0) {
                    this.active = false; score += this.points; scoreEl.innerText = score;
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#ff4400', 4, 5, 40));
                    for(let k=0; k<3; k++) drops.push(new Drop(this.x + (k*10 - 10), this.y, 'star'));
                }
            }
        }

        class LaserEnemy {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.active = true; 
                this.hp = currentSettings.laserHp; 
                this.state = 'enter'; 
                this.timer = 0;
                this.points = 500;
            }
            update() {
                if(!this.active) return;
                this.timer++;
                if (this.state === 'enter') {
                    this.y += 3;
                    if (this.y > 100 + Math.random() * 100) this.state = 'charge';
                } else if (this.state === 'charge') {
                    let trackSpeed = currentSettings.heavyAgile ? 1.0 : 0.5;
                    if (player.x > this.x) this.x += trackSpeed;
                    else this.x -= trackSpeed;
                    if (this.timer > 100) {
                        this.state = 'fire';
                        this.timer = 0;
                    }
                } else if (this.state === 'fire') {
                    if (this.timer > 30) {
                        if (Math.abs(player.x - this.x) < 20) player.hit(2);
                        if (this.timer > 80) {
                            this.state = 'leave';
                        }
                    }
                } else if (this.state === 'leave') {
                    this.y += 5;
                    if (this.y > height + 50) this.active = false;
                }
            }
            draw() {
                if(!this.active) return;
                if (this.state === 'fire' && this.timer > 30) {
                    ctx.save();
                    ctx.shadowBlur = 20; ctx.shadowColor = 'cyan';
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                    ctx.fillRect(this.x - 10, this.y, 20, height);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(this.x - 4, this.y, 8, height);
                    ctx.restore();
                } else if (this.state === 'charge') {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${Math.random()})`;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, height);
                    ctx.stroke();
                }
                ctx.fillStyle = '#00aaaa';
                ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 15);
                ctx.lineTo(this.x + 15, this.y - 15);
                ctx.lineTo(this.x - 15, this.y - 15);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            hit(damage) {
                this.hp -= damage;
                if(this.hp <= 0) {
                    this.active = false; score += this.points; scoreEl.innerText = score;
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#00aaaa', 4, 5, 40));
                    drops.push(new Drop(this.x, this.y, 'health'));
                }
            }
        }

        class Boss {
            constructor() {
                this.x = width / 2; this.y = -100; this.targetY = 150;
                this.maxHp = currentSettings.bossHp;
                this.hp = this.maxHp;
                this.active = false; 
                this.flashTimer = 0;
                this.sequenceIndex = 0; this.phase = 'entry';
                this.currentAttack = 'idle'; this.attackTimer = 0;
                this.laserCharge = 0; this.laserActive = false; this.redLines = [];
                this.isPhaseTwo = false; 
                this.spawnRate = 90 * currentSettings.fireRateMult;
                this.damageMultiplier = 1; 
                this.laserAngle = Math.PI / 2;
                this.isDesperationMode = false;
                this.isTerminator = false; // New Property for Terminator
                this.isGlitch = false; // Stage 3 Boss
                this.clones = []; // For glitch boss
                this.targetX = width / 2; 
                this.shredderMode = false; // Phase 2 Terminator
                this.sawRingTimer = 0; // Phase 3 Terminator
                
                // Shield Props
                this.shieldHp = 0;
                this.maxShieldHp = 2000;
            }

            // Called when starting Stage 2 specifically
            initAsStage2() {
                this.isPhaseTwo = false; 
                this.isTerminator = true;
                this.isGlitch = false;
                this.damageMultiplier = 1.5;
                this.maxHp = (activeDifficultyMode === 'hard') ? 6000 : 3000;
                this.hp = this.maxHp;
                this.shredderMode = false;
                bossName.innerText = activeDifficultyMode === 'hard' ? "TERMINATOR [ELITE]" : "TERMINATOR";
                bossName.style.color = "#ff0000";
                isPhase2Active = false; 
            }

            // Called when starting Stage 3 specifically
            initAsStage3() {
                this.isPhaseTwo = false;
                this.isTerminator = false;
                this.isGlitch = true;
                this.damageMultiplier = 2.0;
                this.maxHp = (activeDifficultyMode === 'hard') ? 8000 : 4000;
                this.hp = this.maxHp;
                bossName.innerText = "PHANTOM PROTOCOL";
                bossName.style.color = "#ff00ff";
                isPhase2Active = false;
                this.clones = [];
            }

            activate() {
                this.active = true;
                bossHud.style.opacity = 1;
            }

            update() {
                if (!this.active) return;
                if (this.flashTimer > 0) this.flashTimer--;

                if (this.phase === 'entry') {
                    this.y += (this.targetY - this.y) * 0.05;
                    if (Math.abs(this.y - this.targetY) < 1) {
                        this.phase = 'fight';
                        this.startNextAttack();
                    }
                    return;
                }

                // --- TERMINATOR SPECIFIC PHASE LOGIC ---
                if (this.isTerminator) {
                    if (!this.shredderMode && this.hp <= 1500) {
                        this.shredderMode = true;
                        this.triggerShredderMode();
                    }
                    if (this.hp <= 750) {
                        this.sawRingTimer++;
                        if (this.sawRingTimer >= 120) {
                            this.sawRingTimer = 0;
                            for(let i=0; i<12; i++) {
                                let angle = (Math.PI*2/12) * i;
                                bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'saw'));
                            }
                            waveText.innerText = "SAW RING DETECTED";
                            waveText.style.opacity = 1;
                            waveText.style.transform = "scale(0.8)";
                            setTimeout(() => { waveText.style.opacity = 0; }, 1000);
                        }
                    }
                    if (this.shredderMode && frames % 60 === 0) {
                        bullets.push(new Bullet(this.x - 100, this.y, -5, 5, 'saw')); 
                        bullets.push(new Bullet(this.x + 100, this.y, 5, 5, 'saw')); 
                    }
                    // Terminator Movement
                    if (this.currentAttack !== 'terminator_laser') {
                        this.x = width/2 + Math.sin(frames * 0.03) * 150;
                    }
                } 
                // --- GLITCH BOSS PHASE LOGIC ---
                else if (this.isGlitch) {
                    // Glitch logic handled in attacks, minimal passive movement
                }
                // --- STANDARD BOSS LOGIC ---
                else {
                      if (!this.isPhaseTwo && this.hp < this.maxHp / 2) {
                        this.triggerPhaseTwo();
                      }
                      if (!this.isDesperationMode && this.hp <= 1000 && this.isPhaseTwo) {
                        this.isDesperationMode = true;
                        for(let i=0; i<20; i++) particles.push(new Particle(this.x, this.y, '#ffffff', 5, 3, 20));
                      }
                      // Standard Movement
                      if (!(this.isDesperationMode && this.laserActive)) {
                        this.x = width/2 + Math.sin(frames * 0.02) * 100;
                      }
                }
                
                this.attackTimer++;
                
                // Passive Spawn (Disabled for Terminator & Glitch)
                if (!this.isTerminator && !this.isGlitch && frames % Math.floor(this.spawnRate) === 0 && this.currentAttack !== 'laser' && this.phase === 'fight') {
                      enemies.push(new SwarmEnemy(this.x - 40, this.y));
                      enemies.push(new SwarmEnemy(this.x + 40, this.y));
                }
                this.handleAttack();
            }

            triggerShredderMode() {
                waveText.innerText = "OPERATION SHREDDER";
                waveText.style.color = "#ff0000";
                waveText.style.opacity = 1;
                waveText.style.transform = "scale(1)";
                setTimeout(() => { waveText.style.opacity = 0; }, 2000);
                for(let i=0; i<50; i++) particles.push(new Particle(this.x, this.y, '#ff0000', 8, 5, 60));
            }

            triggerPhaseTwo() {
                this.isPhaseTwo = true;
                this.damageMultiplier = 2; 
                this.spawnRate = 45 * currentSettings.fireRateMult;        
                for(let i=0; i<100; i++) particles.push(new Particle(this.x, this.y, '#ff3300', 10, 8, 80));
                
                bossName.innerText = "System Core: OMEGA UNLEASHED";
                bossName.style.color = "#ffaa00";
                isPhase2Active = true;

                // TRIGGER SHIELD
                this.shieldHp = 2000;
                bossShieldContainer.style.display = "block";
                bossShieldBar.style.width = "100%";

                createShockwave(this.x, this.y);
                
                flashOverlay.style.transition = 'none';
                flashOverlay.style.opacity = 1;
                void flashOverlay.offsetWidth;
                flashOverlay.style.transition = 'opacity 2s ease-out';
                flashOverlay.style.opacity = 0;
            }

            startNextAttack() {
                let seq = ATTACK_SEQUENCE;
                if(this.isTerminator) seq = TERMINATOR_SEQUENCE;
                if(this.isGlitch) seq = GLITCH_SEQUENCE;
                
                if (this.sequenceIndex >= seq.length) this.sequenceIndex = 0;
                this.currentAttack = seq[this.sequenceIndex];
                this.attackTimer = 0;
                this.sequenceIndex++;
                
                let phaseName = this.currentAttack.toUpperCase();
                if(phaseName.startsWith("TERMINATOR_")) phaseName = phaseName.replace("TERMINATOR_", "");
                if(phaseName.startsWith("GLITCH_")) phaseName = phaseName.replace("GLITCH_", "");
                
                phaseDebug.innerText = `PHASE: ${phaseName}`;
                
                this.laserCharge = 0; this.laserActive = false; this.redLines = [];
                this.laserAngle = Math.PI / 2;
                this.lockTarget = false; 
                this.clones = []; // Reset clones
            }

            handleAttack() {
                switch(this.currentAttack) {
                    // --- GLITCH ATTACKS ---
                    case 'glitch_teleport_rapid':
                        // Teleport every 40 frames and shoot
                        if (this.attackTimer % 40 === 0 && this.attackTimer < 200) {
                            // FX at old pos
                            for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#ff00ff', 4, 3, 20));
                            // Teleport
                            this.x = 50 + Math.random() * (width - 100);
                            this.y = 50 + Math.random() * (height/2);
                            // Fire at player
                            let angle = Math.atan2(player.y - this.y, player.x - this.x);
                            bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*8, Math.sin(angle)*8, 'boss_orb'));
                        }
                        if (this.attackTimer > 240) this.startNextAttack();
                        break;
                        
                    case 'glitch_grid':
                        // Spawn grid
                        if (this.attackTimer === 30) {
                            // Vertical Lines
                            for(let i=0; i<5; i++) {
                                bullets.push(new Bullet(100 + i * (width/5), 0, 0, 0, 'glitch_laser'));
                            }
                            // Horizontal Lines
                            for(let i=0; i<3; i++) {
                                bullets.push(new Bullet(0, 100 + i * 150, 1, 0, 'glitch_laser')); // vx=1 is flag for horizontal
                            }
                        }
                        if (this.attackTimer > 150) this.startNextAttack();
                        break;

                    case 'glitch_clones':
                        if (this.attackTimer === 10) {
                            // Spawn 2 clones
                            this.clones.push({x: this.x - 150, y: this.y + 50});
                            this.clones.push({x: this.x + 150, y: this.y + 50});
                        }
                        // Clones fire too
                        if (this.attackTimer > 40 && this.attackTimer % 30 === 0 && this.attackTimer < 200) {
                            let angle = Math.atan2(player.y - this.y, player.x - this.x);
                            bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*5, Math.sin(angle)*5, 'boss_orb'));
                            this.clones.forEach(c => {
                                let cAngle = Math.atan2(player.y - c.y, player.x - c.x);
                                bullets.push(new Bullet(c.x, c.y, Math.cos(cAngle)*5, Math.sin(cAngle)*5, 'boss_orb'));
                            });
                        }
                        if (this.attackTimer > 250) this.startNextAttack();
                        break;
                        
                    case 'glitch_teleport_fire':
                         // Teleport to center, spray rings
                         if(this.attackTimer === 1) {
                             this.x = width/2; this.y = 100;
                         }
                         if(this.attackTimer % 20 === 0 && this.attackTimer < 200) {
                             let count = 12;
                             for(let i=0; i<count; i++) {
                                 let angle = (Math.PI*2/count)*i + this.attackTimer*0.1;
                                 bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'boss_orb'));
                             }
                         }
                         if(this.attackTimer > 250) this.startNextAttack();
                         break;
                    
                    // --- TERMINATOR ATTACKS ---
                    case 'terminator_fireballs':
                        if (this.attackTimer % 40 === 0 && this.attackTimer < 200) {
                            let angle = Math.atan2(player.y - this.y, player.x - this.x);
                            bullets.push(new Bullet(this.x - 60, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'fireball'));
                            bullets.push(new Bullet(this.x + 60, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'fireball'));
                        }
                        if (this.attackTimer > 250) this.startNextAttack();
                        break;

                    case 'terminator_rapid':
                         if (this.attackTimer % 10 === 0 && this.attackTimer < 150) {
                            bullets.push(new Bullet(this.x, this.y + 40, (Math.random()-0.5)*2, 8, 'fireball'));
                         }
                         if (this.attackTimer > 200) this.startNextAttack();
                         break;

                    case 'terminator_laser':
                        if (this.attackTimer < 60) {
                            this.laserCharge = this.attackTimer / 60;
                            let target = Math.atan2(player.y - this.y, player.x - this.x);
                            this.laserAngle = target; 
                        } else if (this.attackTimer === 60) {
                            this.lockTarget = true; 
                        } else if (this.attackTimer < 160) {
                            this.laserActive = true;
                            let angle = this.laserAngle; 
                            let dx = player.x - this.x; let dy = player.y - this.y;
                            let rAngle = -angle + Math.PI/2;
                            let rx = dx * Math.cos(rAngle) - dy * Math.sin(rAngle);
                            let ry = dx * Math.sin(rAngle) + dy * Math.cos(rAngle);
                            if (Math.abs(rx) < 30 && ry > 0) player.hit(2);
                        } else {
                            this.laserActive = false;
                            this.lockTarget = false;
                            if (this.attackTimer > 200) this.startNextAttack();
                        }
                        break;

                    // --- STANDARD BOSS ATTACKS ---
                    case 'laser':
                        if (this.attackTimer < 60) {
                            this.laserCharge = this.attackTimer / 60;
                            if (this.isDesperationMode) {
                                let target = Math.atan2(player.y - this.y, player.x - this.x);
                                let diff = target - this.laserAngle;
                                while (diff < -Math.PI) diff += Math.PI * 2;
                                while (diff > Math.PI) diff -= Math.PI * 2;
                                this.laserAngle += diff * 0.1;
                            } else {
                                this.laserAngle = Math.PI / 2;
                            }
                        } else if (this.attackTimer < 160) {
                            this.laserActive = true; 
                            let hit = false;
                            if (this.isDesperationMode) {
                                let dx = player.x - this.x; let dy = player.y - this.y;
                                let angle = -(this.laserAngle - Math.PI/2);
                                let rx = dx * Math.cos(angle) - dy * Math.sin(angle);
                                if (Math.abs(rx) < 30 && dy > 0) hit = true; 
                            } else {
                                if (Math.abs(player.x - this.x) < 30) hit = true;
                            }
                            if (hit) player.hit(2 * this.damageMultiplier);
                            if (frames % 4 === 0) {
                                ctx.translate(Math.random()*4-2, 0);
                                setTimeout(()=>ctx.setTransform(1,0,0,1,0,0), 20);
                            }
                        } else {
                            this.laserActive = false;
                            if (this.attackTimer > 200) this.startNextAttack();
                        }
                        break;

                    case 'swarm':
                         if (this.attackTimer === 1) {
                            let count = this.isPhaseTwo ? 15 : 10;
                            count = Math.floor(count * currentSettings.enemyCountMult);
                            for(let i=0; i<count; i++) enemies.push(new SwarmEnemy(Math.random() * width, -50 - (i*50)));
                        }
                        if (this.attackTimer > 400) this.startNextAttack();
                        break;
                    case 'redLines':
                        if (this.attackTimer === 1) {
                            let count = Math.ceil(5 * currentSettings.enemyCountMult);
                            for(let i=0; i<count; i++) this.redLines.push({x: Math.random() * width, width: 2, damage: false});
                        }
                        if (this.attackTimer > 100 && this.attackTimer < 160) {
                            this.redLines.forEach(l => {
                                l.width = 40; l.damage = true;
                                if (l.damage && Math.abs(player.x - l.x) < 20) player.hit(1 * this.damageMultiplier);
                            });
                        }
                        if (this.attackTimer > 200) this.startNextAttack();
                        break;
                    case 'rings':
                        if (this.attackTimer % 40 === 0 && this.attackTimer < 300) {
                            let count = this.isPhaseTwo ? 24 : 16;
                            count = Math.floor(count * currentSettings.enemyCountMult);
                            for (let i = 0; i < count; i++) {
                                let angle = (Math.PI * 2 / count) * i + (this.attackTimer * 0.01);
                                bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*5, Math.sin(angle)*5, 'boss_orb'));
                            }
                        }
                        if (this.attackTimer > 350) this.startNextAttack();
                        break;
                    case 'missiles':
                        if (this.attackTimer % 30 === 0 && this.attackTimer < 200) {
                            bullets.push(new Bullet(this.x - 50, this.y, -3, -3, 'missile'));
                            bullets.push(new Bullet(this.x + 50, this.y, 3, -3, 'missile'));
                            if(this.isPhaseTwo) bullets.push(new Bullet(this.x, this.y - 20, 0, -4, 'missile'));
                        }
                        if (this.attackTimer > 300) this.startNextAttack();
                        break;
                    case 'fireballs': // Default boss fireball
                        if (this.attackTimer % 30 === 0 && this.attackTimer < 200) {
                            bullets.push(new Bullet(this.x - 40, this.y, (player.x - (this.x-40))*0.02, (player.y-this.y)*0.02, 'fireball'));
                            bullets.push(new Bullet(this.x + 40, this.y, (player.x - (this.x+40))*0.02, (player.y-this.y)*0.02, 'fireball'));
                        }
                        if (this.attackTimer > 250) this.startNextAttack();
                        break;
                }
            }

            draw() {
                if (!this.active) return;
                
                // --- GLITCH DRAWING ---
                if (this.isGlitch) {
                    ctx.save();
                    
                    // Draw Main Boss (Visual is handled by 3D mostly, but 2D hit area needed)
                    // Draw a flickering diamond shape
                    ctx.translate(this.x, this.y);
                    if(frames % 4 === 0) ctx.translate((Math.random()-0.5)*10, 0); // Glitch jitter
                    
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15; ctx.shadowColor = '#ff00ff';
                    ctx.beginPath();
                    ctx.moveTo(0, -60); ctx.lineTo(60, 0); ctx.lineTo(0, 60); ctx.lineTo(-60, 0); ctx.closePath();
                    ctx.stroke();
                    
                    // Inner Fill
                    ctx.fillStyle = `rgba(255, 0, 255, ${0.2 + Math.sin(frames*0.1)*0.2})`;
                    ctx.fill();

                    ctx.restore();

                    // Draw Clones
                    this.clones.forEach(c => {
                        ctx.save();
                        ctx.translate(c.x, c.y);
                        ctx.globalAlpha = 0.4 + Math.sin(frames*0.5)*0.2; // Ghostly
                        ctx.strokeStyle = '#00ffff'; // Cyan clones
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -50); ctx.lineTo(50, 0); ctx.lineTo(0, 50); ctx.lineTo(-50, 0); ctx.closePath();
                        ctx.stroke();
                        ctx.restore();
                    });
                    
                    return;
                }

                // --- TERMINATOR DRAWING (GIANT RED SHIP) ---
                if (this.isTerminator) {
                      ctx.save(); ctx.translate(this.x, this.y);
                      
                      // TERMINATOR LASER
                      if (this.currentAttack === 'terminator_laser') {
                          ctx.rotate(this.laserAngle - Math.PI/2);
                          
                          if (this.attackTimer < 60) {
                               ctx.fillStyle = `rgba(255, 0, 0, ${this.laserCharge})`;
                               ctx.beginPath(); ctx.arc(0, 0, this.laserCharge * 20, 0, Math.PI*2); ctx.fill();
                               ctx.strokeStyle = "rgba(255, 0, 0, 0.3)"; ctx.lineWidth = 2;
                               ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 1000); ctx.stroke();
                          }
                          else if (this.laserActive) {
                              ctx.save();
                              ctx.shadowBlur = 40; ctx.shadowColor = "red";
                              ctx.fillStyle = "rgba(255, 0, 0, 0.9)";
                              ctx.fillRect(-30, 0, 60, height * 1.5);
                              ctx.fillStyle = "white";
                              ctx.fillRect(-10, 0, 20, height * 1.5);
                              ctx.restore();
                          }
                          ctx.rotate(-(this.laserAngle - Math.PI/2));
                      }
                      
                      // 2D SHIELD FOR TERMINATOR
                      if (this.shieldHp > 0) {
                          ctx.save();
                          if(this.currentAttack === 'terminator_laser') ctx.rotate(this.laserAngle - Math.PI/2);
                          else ctx.rotate(Math.PI); 
                          ctx.beginPath();
                          ctx.arc(0, 10, 80, 0, Math.PI*2); 
                          ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(frames*0.1)*0.2})`;
                          ctx.lineWidth = 5;
                          ctx.shadowBlur = 20; ctx.shadowColor = "cyan";
                          ctx.stroke();
                          ctx.fillStyle = "rgba(0, 255, 255, 0.1)";
                          ctx.fill();
                          ctx.restore();
                      }

                      ctx.scale(4, 4);
                      ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000'; ctx.fillStyle = '#ffcccc';
                      ctx.rotate(Math.PI);
                      ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(15, 15); ctx.lineTo(0, 10); ctx.lineTo(-15, 15); ctx.fill();
                      ctx.fillStyle = '#880000';
                      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(20, 10); ctx.lineTo(20, 25); ctx.lineTo(5, 15); ctx.fill();
                      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-20, 10); ctx.lineTo(-20, 25); ctx.lineTo(-5, 15); ctx.fill();
                      ctx.fillStyle = "#ffaa00";
                      ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

                      if (this.flashTimer > 0) {
                          ctx.globalCompositeOperation = 'source-over';
                          ctx.fillStyle = "white";
                          ctx.fill();
                      }

                      ctx.restore();
                      return; 
                }

                // --- STANDARD BOSS DRAWING ---
                ctx.save(); ctx.translate(this.x, this.y);

                // 2D SHIELD BACKUP FOR SYSTEM CORE
                if (this.shieldHp > 0) {
                     ctx.save();
                     ctx.beginPath();
                     ctx.arc(0, 0, 90, 0, Math.PI*2); // 90px radius
                     ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 + Math.sin(frames*0.2)*0.3})`;
                     ctx.lineWidth = 3;
                     ctx.shadowBlur = 15; ctx.shadowColor = "#00ffff";
                     ctx.stroke();
                     ctx.fillStyle = "rgba(0, 255, 255, 0.15)";
                     ctx.fill();
                     ctx.restore();
                }

                if (this.currentAttack === 'laser') {
                    ctx.rotate(this.laserAngle - Math.PI / 2);

                    if (this.attackTimer < 60) {
                        ctx.strokeStyle = `rgba(255, 0, 0, ${Math.random()})`; ctx.lineWidth = 1;
                        for(let i=0; i<5; i++) {
                            ctx.beginPath(); ctx.moveTo((Math.random()-0.5)*200, 200); ctx.lineTo(0, 40); ctx.stroke();
                        }
                        ctx.fillStyle = `rgba(255, 200, 200, ${this.laserCharge})`;
                        ctx.beginPath(); ctx.arc(0, 50, this.laserCharge * 20, 0, Math.PI*2); ctx.fill();
                    } else if (this.laserActive) {
                        ctx.save(); ctx.shadowBlur = 40; ctx.shadowColor = "red";
                        const beamWidth = 60 + Math.sin(frames * 0.5) * 5;
                        ctx.fillStyle = this.isPhaseTwo ? "rgba(255, 50, 0, 0.9)" : "rgba(255, 0, 0, 0.7)";
                        ctx.fillRect(-beamWidth/2, 0, beamWidth, height * 1.5); 
                        ctx.fillStyle = "white"; ctx.fillRect(-beamWidth/4, 0, beamWidth/2, height * 1.5);
                        ctx.restore();
                        
                        if (Math.random() > 0.5) particles.push(new Particle(this.x, this.y + 50, '#ff5500', 5, 8, 30));
                    }
                }

                if (this.isPhaseTwo) ctx.globalAlpha = 0.5;

                if (this.flashTimer > 0) { ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = '#ffffff'; }
                else { ctx.shadowBlur = 30; ctx.shadowColor = '#ff3300'; ctx.fillStyle = '#880000'; }
                
                ctx.rotate(-(this.laserAngle - Math.PI / 2)); 

                ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.fill();
                if (this.flashTimer > 0) ctx.globalCompositeOperation = 'source-over';
                
                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(0, 0, 60, frames * 0.1, frames * 0.1 + 4); ctx.stroke();
                ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0, 0, 70, -frames * 0.1, -frames * 0.1 + 4); ctx.stroke();
                ctx.restore();
                ctx.globalAlpha = 1.0;

                if (this.currentAttack === 'redLines') {
                    this.redLines.forEach(l => {
                        ctx.save();
                        if (!l.damage) {
                            ctx.strokeStyle = `rgba(255, 0, 0, ${Math.abs(Math.sin(frames * 0.2))})`;
                            ctx.lineWidth = 2; ctx.setLineDash([10, 10]);
                            ctx.beginPath(); ctx.moveTo(l.x, 0); ctx.lineTo(l.x, height); ctx.stroke();
                        } else {
                            ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000';
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.fillRect(l.x - 20, 0, 40, height);
                            ctx.fillStyle = '#fff'; ctx.fillRect(l.x - 2, 0, 4, height);
                        }
                        ctx.restore();
                    });
                }
            }
            hit(damage) {
                if (this.phase !== 'fight') return;
                
                // SHIELD MECHANIC
                if (this.shieldHp > 0) {
                    this.shieldHp -= damage;
                    bossShieldBar.style.width = `${(this.shieldHp / this.maxShieldHp) * 100}%`;
                    if (this.shieldHp <= 0) {
                        bossShieldBar.style.width = "0%";
                        bossShieldContainer.style.display = "none"; // Hide bar container when shield is gone
                        for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, '#00ffff', 5, 5, 40));
                    }
                    return; 
                }

                this.hp -= damage;
                this.flashTimer = 4;
                bossHealthBar.style.width = `${(this.hp / this.maxHp) * 100}%`;
                if (this.hp <= 0 && this.active) {
                    this.active = false; bossHealthBar.style.width = '0%';
                    isPhase2Active = false;
                    this.isTerminator = false;
                    for(let i=0; i<100; i++) {
                        particles.push(new Particle(this.x, this.y, '#ffaa00', 10, 8, 100));
                        particles.push(new Particle(this.x, this.y, '#ffffff', 15, 5, 120));
                    }
                    
                    flashOverlay.style.transition = 'none';
                    flashOverlay.style.opacity = 1;
                    void flashOverlay.offsetWidth;
                    flashOverlay.style.transition = 'opacity 2s ease-out';
                    flashOverlay.style.opacity = 0;
                    
                    let dropCount = 50;
                    for(let k=0; k<dropCount; k++) {
                        drops.push(new Drop(this.x + (Math.random()-0.5)*500, this.y, 'star'));
                    }

                    triggerSupernova();
                    startVictorySequence();
                }
            }
        }

        function createShockwave(x, y) {
             for(let i=0; i<360; i+=10) {
                 let angle = i * Math.PI / 180;
                 particles.push(new Particle(x, y, '#ffffff', 10, 3, 20));
             }
        }

        let currentWave = 0;
        let waveClearCheckReady = false; 

        function startWave(wave) {
            currentWave = wave;
            waveClearCheckReady = false; 
            
            // Cap logic
            let maxWaves = (currentLevelIndex === 2 || currentLevelIndex === 3) ? 15 : 10;

            waveText.innerText = currentWave === maxWaves ? "BOSS WARNING" : `WAVE ${currentWave}`;
            waveText.style.color = "#fff"; 
            waveText.style.opacity = 1;
            waveText.style.transform = "scale(1.2)";
            
            setTimeout(() => {
                waveText.style.opacity = 0;
                waveText.style.transform = "scale(0.5)";
                spawnWaveEnemies(wave);
            }, 2000);
        }

        function spawnWaveEnemies(wave) {
            let maxDelay = 0;
            const countMult = currentSettings.enemyCountMult;

            // ===============================================
            // STAGE 2 & STAGE 3 LOGIC 
            // ===============================================
            if (currentLevelIndex === 2 || currentLevelIndex === 3) {
                
                let isHard = (activeDifficultyMode === 'hard');

                if (wave === 1) {
                    if(isHard) {
                        enemies.push(new HeavyStriker(width*0.25, -100));
                        enemies.push(new HeavyStriker(width*0.5, -200));
                        enemies.push(new HeavyStriker(width*0.75, -100));
                        maxDelay = 500;
                    } else {
                        let count = Math.ceil((12 + wave * 2) * countMult);
                        for(let i=0; i<count; i++) {
                            let d = i * (400 - wave * 20); if(d>maxDelay) maxDelay=d;
                            setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                        }
                    }
                } else if (wave >= 2 && wave <= 5) {
                     // Swarm + Heavy Mix
                     let count = Math.ceil(20 * countMult);
                     for(let i=0; i<count; i++) {
                         let d = i * 200; if(d>maxDelay) maxDelay=d;
                         setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                     }
                     setTimeout(() => enemies.push(new HeavyStriker(Math.random()*width, -200)), 1000);
                } else if (wave >= 6 && wave <= 10) {
                     // Laser Intro
                     enemies.push(new LaserEnemy(width*0.2, -100));
                     enemies.push(new LaserEnemy(width*0.8, -100));
                     let count = Math.ceil(15 * countMult);
                     for(let i=0; i<count; i++) {
                         setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), i*300);
                     }
                     maxDelay = 2000;
                } else if (wave >= 11 && wave <= 14) {
                     // Hard Mix
                     enemies.push(new HeavyStriker(width*0.3, -100));
                     enemies.push(new HeavyStriker(width*0.7, -100));
                     enemies.push(new LaserEnemy(width*0.5, -200));
                     let count = Math.ceil(25 * countMult);
                     for(let i=0; i<count; i++) {
                         let d = i*150; if(d>maxDelay) maxDelay=d;
                         setTimeout(() => enemies.push(new SwarmEnemy(Math.random()*width, -50)), d);
                     }
                } else if (wave === 15) {
                     boss.activate();
                     if (currentLevelIndex === 2) boss.initAsStage2();
                     else boss.initAsStage3();
                }
            } 
            // ===============================================
            // STAGE 1 DEFAULT LOGIC
            // ===============================================
            else {
                if (wave === 1) {
                    let count = Math.ceil(10 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = i*400; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 2) {
                    let count = Math.ceil(16 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = i*300; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 3) {
                    let count = Math.ceil(24 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = i*200; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 4) {
                    setTimeout(() => enemies.push(new HeavyStriker(width/2, -100)), 0);
                    let count = Math.ceil(15 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = 1000 + i*300; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 5) {
                    enemies.push(new HeavyStriker(width/4, -100));
                    enemies.push(new HeavyStriker(width*2/4, -150));
                    enemies.push(new HeavyStriker(width*3/4, -100));
                    let count = Math.ceil(20 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = 2000 + i*250; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                    maxDelay = 2000 + count*250;
                } else if (wave === 6) {
                    enemies.push(new LaserEnemy(width*0.2, -100));
                    enemies.push(new LaserEnemy(width*0.8, -100));
                    let count = Math.ceil(20 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = i*200; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                } else if (wave === 7) {
                    enemies.push(new LaserEnemy(width*0.1, -100));
                    enemies.push(new LaserEnemy(width*0.9, -100));
                    setTimeout(() => enemies.push(new HeavyStriker(width/2, -100)), 500);
                    setTimeout(() => enemies.push(new HeavyStriker(width/4, -100)), 1000);
                    setTimeout(() => enemies.push(new HeavyStriker(width*3/4, -100)), 1500);
                    maxDelay = 1500;
                } else if (wave === 8) {
                    enemies.push(new LaserEnemy(width/2, -100));
                    enemies.push(new LaserEnemy(200, -200));
                    enemies.push(new LaserEnemy(width-200, -200));
                    let count = Math.ceil(30 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = 1000 + i*200; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                    maxDelay = 1000 + count*200;
                } else if (wave === 9) {
                    enemies.push(new LaserEnemy(width*0.2, -100));
                    enemies.push(new LaserEnemy(width*0.8, -100));
                    enemies.push(new HeavyStriker(width/3, -200));
                    enemies.push(new HeavyStriker(width*2/3, -200));
                    let count = Math.ceil(40 * countMult);
                    for(let i=0; i<count; i++) { 
                        let d = 500 + i*150; if(d>maxDelay) maxDelay=d;
                        setTimeout(() => enemies.push(new SwarmEnemy(Math.random() * width, -50)), d);
                    }
                    maxDelay = 500 + count*150;
                } else if (wave === 10) {
                    boss.activate();
                }
            }

            setTimeout(() => {
                waveClearCheckReady = true;
            }, maxDelay + 500);
        }

        let player, boss;
        let particles = [], bullets = [], enemies = [], drops = [];
        let score = 0, frames = 0;
        let victoryTimer = 0;

        function showExpertSelect() {
            gameState = STATE.LEVEL_SELECT;
            menuScreen.style.opacity = '0';
            menuScreen.style.pointerEvents = 'none';
            expertSelectScreen.style.opacity = '1';
            expertSelectScreen.style.pointerEvents = 'auto';
            updateLevelGrid('hard');
        }

        function showRookieSelect() {
            gameState = STATE.LEVEL_SELECT;
            menuScreen.style.opacity = '0';
            menuScreen.style.pointerEvents = 'none';
            levelSelectScreen.style.opacity = '1';
            levelSelectScreen.style.pointerEvents = 'auto';
            updateLevelGrid('easy');
        }

        // --- NEW: STAGE LOCK & GRID GENERATION ---
        function updateLevelGrid(mode) {
            const stats = (mode === 'easy') ? gameData.easy : gameData.hard;
            const gridId = (mode === 'easy') ? 'easy-grid' : 'hard-grid';
            const gridEl = document.getElementById(gridId);
            
            gridEl.innerHTML = ''; // Clear existing

            for(let i = 1; i <= 3; i++) { // Changed 2 to 3
                const btn = document.createElement('button');
                btn.className = 'level-btn';
                
                if (i <= stats.maxStage) {
                    // UNLOCKED
                    btn.classList.add('active');
                    btn.innerText = i < 10 ? `0${i}` : i;
                    btn.onclick = () => launchMission(mode, i);
                } else {
                    // LOCKED
                    btn.classList.add('locked');
                    btn.innerHTML = `${i < 10 ? '0'+i : i} <span style="font-size:12px">üîí</span>`;
                    btn.onclick = showLockedMessage;
                }
                gridEl.appendChild(btn);
            }
        }

        function showLockedMessage() {
            msgModal.style.display = 'block';
        }

        function closeMsgModal() {
            msgModal.style.display = 'none';
        }

        // --- HANGAR LOGIC ---
        function openHangar(mode) {
            gameState = STATE.HANGAR;
            currentHangarMode = mode; 
            const stats = (mode === 'easy') ? gameData.easy : gameData.hard;
            document.getElementById('hangar-stars').innerText = stats.stars;
            document.getElementById('hangar-title').innerText = (mode === 'easy' ? "ROOKIE" : "EXPERT") + " HANGAR";
            updateHangarUI();
            levelSelectScreen.style.opacity = '0'; levelSelectScreen.style.pointerEvents = 'none';
            expertSelectScreen.style.opacity = '0'; expertSelectScreen.style.pointerEvents = 'none';
            hangarScreen.style.opacity = '1'; hangarScreen.style.pointerEvents = 'auto';
            const hCanvas = document.getElementById('hangarShipCanvas');
            const hCtx = hCanvas.getContext('2d');
            hCtx.clearRect(0,0,200,200);
            hCtx.save(); hCtx.translate(100, 100); hCtx.scale(2, 2); 
            hCtx.shadowBlur = 20; hCtx.shadowColor = '#00ffff'; hCtx.fillStyle = '#fff';
            hCtx.beginPath(); hCtx.moveTo(0, -20); hCtx.lineTo(15, 15); hCtx.lineTo(0, 10); hCtx.lineTo(-15, 15); hCtx.fill();
            hCtx.fillStyle = '#00aaaa'; hCtx.beginPath(); hCtx.moveTo(0, 0); hCtx.lineTo(20, 10); hCtx.lineTo(20, 25); hCtx.lineTo(5, 15); hCtx.fill();
            hCtx.beginPath(); hCtx.moveTo(0, 0); hCtx.lineTo(-20, 10); hCtx.lineTo(-20, 25); hCtx.lineTo(-5, 15); hCtx.fill();
            hCtx.restore();
        }

        function closeHangar() {
            gameState = STATE.LEVEL_SELECT; 
            hangarScreen.style.opacity = '0'; hangarScreen.style.pointerEvents = 'none';
            const title = document.getElementById('hangar-title').innerText;
            if(title.includes("EXPERT")) {
                expertSelectScreen.style.opacity = '1'; expertSelectScreen.style.pointerEvents = 'auto';
                updateLevelGrid('hard');
            } else {
                levelSelectScreen.style.opacity = '1'; levelSelectScreen.style.pointerEvents = 'auto';
                updateLevelGrid('easy');
            }
        }

        function updateHangarUI() {
            const stats = (currentHangarMode === 'easy') ? gameData.easy : gameData.hard;
            document.getElementById('hangar-stars').innerText = stats.stars;
            
            // --- UPDATE HP CARD ---
            const hpLvl = stats.healthLvl;
            const hpBtn = document.getElementById('btn-upg-hp');
            const hpBonusEl = document.getElementById('hp-bonus');
            let totalBonusHp = 0;
            for(let i=0; i<hpLvl; i++) totalBonusHp += HEALTH_UPGRADES.bonuses[i];
            
            const hpSegments = document.querySelectorAll('#hp-bar-container .level-segment');
            hpSegments.forEach((seg, index) => {
                if (index < hpLvl) seg.classList.add('active');
                else seg.classList.remove('active');
            });

            hpBonusEl.innerText = "+" + totalBonusHp + " HP";
            if (hpLvl >= 5) {
                hpBtn.innerText = "MAXED";
                hpBtn.style.opacity = 0.5;
                hpBtn.style.cursor = "default";
                hpBtn.onclick = null;
            } else {
                const cost = HEALTH_UPGRADES.costs[hpLvl];
                hpBtn.innerText = `UPGRADE (${cost} ‚≠ê)`;
                hpBtn.style.opacity = 1;
                hpBtn.style.cursor = "pointer";
                hpBtn.onclick = upgradeHealth; 
            }

            // --- UPDATE CANNON CARD ---
            const cannonLvl = stats.cannonLvl;
            const cannonBtn = document.getElementById('btn-upg-cannon');
            const cannonBonusEl = document.getElementById('cannon-bonus');
            let totalBonusDmg = 0;
            for(let i=0; i<cannonLvl; i++) totalBonusDmg += CANNON_UPGRADES.bonuses[i];

            const cannonSegments = document.querySelectorAll('#cannon-bar-container .level-segment');
            cannonSegments.forEach((seg, index) => {
                if (index < cannonLvl) seg.classList.add('active');
                else seg.classList.remove('active');
            });

            cannonBonusEl.innerText = "+" + totalBonusDmg + " DMG";
            if (cannonLvl >= 5) {
                cannonBtn.innerText = "MAXED";
                cannonBtn.style.opacity = 0.5;
                cannonBtn.style.cursor = "default";
                cannonBtn.onclick = null;
            } else {
                const cost = CANNON_UPGRADES.costs[cannonLvl];
                cannonBtn.innerText = `UPGRADE (${cost} ‚≠ê)`;
                cannonBtn.style.opacity = 1;
                cannonBtn.style.cursor = "pointer";
                cannonBtn.onclick = upgradeCannon; 
            }
        }

        function upgradeHealth() {
            const stats = (currentHangarMode === 'easy') ? gameData.easy : gameData.hard;
            const currentLvl = stats.healthLvl;
            if (currentLvl >= 5) return;
            const cost = HEALTH_UPGRADES.costs[currentLvl];
            if (stats.stars >= cost) {
                stats.stars -= cost;
                stats.healthLvl++;
                saveData();
                updateHangarUI();
            } else {
                alert("Not enough stars!"); 
            }
        }

        function upgradeCannon() {
            const stats = (currentHangarMode === 'easy') ? gameData.easy : gameData.hard;
            const currentLvl = stats.cannonLvl;
            if (currentLvl >= 5) return;
            const cost = CANNON_UPGRADES.costs[currentLvl];
            if (stats.stars >= cost) {
                stats.stars -= cost;
                stats.cannonLvl++;
                saveData();
                updateHangarUI();
            } else {
                alert("Not enough stars!"); 
            }
        }

        function updateUI() {
            if(activeDifficultyMode === 'easy') {
                starsDisplayEl.innerText = gameData.easy.stars;
            } else {
                starsDisplayEl.innerText = gameData.hard.stars;
            }
        }

        // --- INTRO / BRIEFING LOGIC ---
        function launchMission(mode, levelIndex) {
            currentSettings = mode === 'hard' ? DIFFICULTY.NORMAL : DIFFICULTY.EASY;
            activeDifficultyMode = mode;
            currentLevelIndex = levelIndex;
            
            // Hide menu screens
            menuScreen.style.opacity = '0'; menuScreen.style.pointerEvents = 'none';
            levelSelectScreen.style.opacity = '0'; levelSelectScreen.style.pointerEvents = 'none';
            expertSelectScreen.style.opacity = '0'; expertSelectScreen.style.pointerEvents = 'none';
            gameOverScreen.style.opacity = '0'; gameOverScreen.style.pointerEvents = 'none';
            hangarScreen.style.opacity = '0'; hangarScreen.style.pointerEvents = 'none';
            
            // Trigger Intro State
            startIntro(mode, levelIndex);
        }

        function startIntro(mode, levelIndex) {
            gameState = STATE.INTRO;
            introScreen.style.opacity = '1'; introScreen.style.pointerEvents = 'auto';
            
            // Set message
            const key = `${mode}_${levelIndex}`;
            const msg = STAGE_MESSAGES[key] || "Transmission unclear. Proceed with caution.";
            document.getElementById('radio-content').innerHTML = msg;
            
            // Reset timer
            introTimer = 30;
            document.getElementById('intro-countdown').innerText = introTimer;
            if(introInterval) clearInterval(introInterval);
            introInterval = setInterval(() => {
                introTimer--;
                document.getElementById('intro-countdown').innerText = introTimer;
                if(introTimer <= 0) skipIntro();
            }, 1000);
        }

        function skipIntro() {
            if(introInterval) clearInterval(introInterval);
            introScreen.style.opacity = '0'; introScreen.style.pointerEvents = 'none';
            startActualGameplay();
        }

        function startActualGameplay() {
            document.activeElement.blur();

            player = new Player();
            boss = new Boss();
            bullets = []; particles = []; enemies = []; drops = [];
            score = 0; frames = 0;
            scoreEl.innerText = '0'; playerHpEl.innerText = '100';
            stageDisplayEl.innerText = currentLevelIndex;
            bossHealthBar.style.width = '100%';
            bossShieldBar.style.width = '0%';
            bossName.innerText = "System Core: Omega"; 
            bossName.style.color = "#ff4d4d";
            
            updateUI(); 

            gameState = STATE.PLAYING;
            isPhase2Active = false;
            
            playerHud.style.opacity = '1'; canvas.style.opacity = '1';
            bossHud.style.opacity = 0; 
            
            mouse.targetX = width/2; mouse.targetY = height - 100;

            currentWave = 0;
            startWave(1);
        }

        function startVictorySequence() {
            gameState = STATE.VICTORY_SEQUENCE;
            victoryTimer = 0;
            enemies = [];
            bullets = [];
            bossHud.style.opacity = 0;
            waveText.innerText = "MISSION COMPLETE";
            waveText.style.opacity = 1;
            waveText.style.transform = "scale(1)";
            waveText.style.color = "#00ff00";
            waveText.style.textShadow = "0 0 20px #00ff00";
        }

        function resetToMenu() {
            gameState = STATE.MENU;
            menuScreen.style.opacity = '1'; menuScreen.style.pointerEvents = 'auto';
            levelSelectScreen.style.opacity = '0'; levelSelectScreen.style.pointerEvents = 'none';
            expertSelectScreen.style.opacity = '0'; expertSelectScreen.style.pointerEvents = 'none';
            gameOverScreen.style.opacity = '0'; gameOverScreen.style.pointerEvents = 'none';
            playerHud.style.opacity = '0';
            canvas.style.opacity = '0'; 
            bossHud.style.opacity = 0;
            enemies = []; bullets = []; particles = []; drops = [];
            isSupernovaExploding = false;
            if(supernovaMesh) supernovaMesh.visible = false;
            if(supernovaParticles) supernovaParticles.visible = false;
            dropMeshes.forEach(d => { if(d.mesh) { scene.remove(d.mesh); d.mesh.geometry.dispose(); d.mesh.material.dispose(); } });
            dropMeshes = [];
        }

        function gameOver(win) {
            gameState = STATE.GAMEOVER;
            gameOverScreen.style.opacity = '1'; gameOverScreen.style.pointerEvents = 'auto';
            gameOverTitle.innerText = win ? "STAGE CLEARED" : "MISSION FAILED";
            gameOverTitle.style.color = win ? "#00ff00" : "#ff0000";
            waveText.style.opacity = 0;

            // STAGE PROGRESSION LOGIC
            if (win) {
                const stats = (activeDifficultyMode === 'easy') ? gameData.easy : gameData.hard;
                // If we beat current max stage, unlock next (capped at 3 now)
                if (currentLevelIndex === stats.maxStage && stats.maxStage < 3) {
                    stats.maxStage++;
                    saveData();
                }
            }
        }

        function animateGame() {
            requestAnimationFrame(animateGame);
            ctx.fillStyle = 'rgba(5, 5, 5, 0.4)'; ctx.fillRect(0, 0, width, height);
            if (frames % 2 === 0) { ctx.fillStyle = `rgba(255, 255, 255, ${Math.random()})`; ctx.fillRect(Math.random() * width, 0, 2, 2); }
            if (gameState === STATE.MENU) return;

            frames++;
            if (gameState === STATE.PLAYING || gameState === STATE.GAMEOVER || gameState === STATE.VICTORY_SEQUENCE) {
                
                let maxWaves = (activeDifficultyMode === 'easy' && currentLevelIndex === 2) ? 15 : 10;
                if(currentLevelIndex === 3) maxWaves = 15; // Ensure Stage 3 has same wave cap

                if (gameState === STATE.PLAYING && currentWave < maxWaves && enemies.length === 0 && waveClearCheckReady) {
                    if (frames % 60 === 0) { 
                        startWave(currentWave + 1);
                    }
                }

                if (boss && boss.active) { boss.update(); boss.draw(); }
                
                if (player) {
                    if (gameState === STATE.PLAYING) {
                        player.update();
                        player.draw();
                        for (let i = enemies.length - 1; i >= 0; i--) {
                            let e = enemies[i]; e.update(); e.draw(); 
                            if (!e.active) enemies.splice(i, 1);
                        }
                        for (let i = drops.length - 1; i >= 0; i--) {
                            let d = drops[i]; d.update(); d.draw();
                            if (!d.active) drops.splice(i, 1);
                        }
                        for (let i = bullets.length - 1; i >= 0; i--) {
                            let b = bullets[i]; b.update(); b.draw();
                            if (!b.active) { bullets.splice(i, 1); continue; }
                            
                            if (b.type === 'player') {
                                let hit = false;
                                if (boss.active) {
                                    let dx = b.x - boss.x; let dy = b.y - boss.y;
                                    if (Math.sqrt(dx*dx + dy*dy) < 60) { 
                                         boss.hit(b.damage); b.active = false; hit = true;
                                         particles.push(new Particle(b.x, b.y, '#ffaa00', 2, 2, 10));
                                    }
                                }
                                if (!hit) {
                                    enemies.forEach(e => {
                                        if (e.active && Math.abs(b.x - e.x) < 20 && Math.abs(b.y - e.y) < 20) {
                                            e.hit(b.damage); b.active = false;
                                        }
                                    });
                                }
                            } else {
                                let dx = b.x - player.x; let dy = b.y - player.y;
                                if (Math.sqrt(dx*dx + dy*dy) < 15) { 
                                    player.hit(b.damage); b.active = false;
                                    particles.push(new Particle(b.x, b.y, '#00ffff', 2, 2, 10));
                                }
                            }
                        }
                    } else if (gameState === STATE.VICTORY_SEQUENCE) {
                        player.draw(); 
                        drops.forEach(d => { d.x += (player.x - d.x)*0.1; d.y += (player.y - d.y)*0.1; if(Math.abs(d.x-player.x)<20) d.collect(); d.draw(); });
                        victoryTimer++;
                        if (victoryTimer <= 100) {
                            player.x += (Math.random() - 0.5) * 2;
                            if(frames % 5 === 0) particles.push(new Particle(player.x, player.y + 20, '#00ffff', 1, 3, 5));
                        }
                        if (victoryTimer > 100) {
                            player.y -= 12;
                            particles.push(new Particle(player.x, player.y + 20, '#00ffff', 2, 6, 15));
                            particles.push(new Particle(player.x - 5, player.y + 20, '#00ffff', 1, 3, 10));
                            particles.push(new Particle(player.x + 5, player.y + 20, '#00ffff', 1, 3, 10));
                            if (player.y < -50) gameOver(true);
                        }
                    }
                }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1);
            }
        }

        // --- DEV TOOL LOGIC ---
        function toggleDevPanel() {
            const panel = document.getElementById('dev-panel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        }

        function devSetStars() {
            const val = parseInt(document.getElementById('dev-stars').value);
            if (!isNaN(val)) {
                if (activeDifficultyMode === 'easy') gameData.easy.stars = val;
                else gameData.hard.stars = val;
                saveData();
                updateUI();
                if (gameState === STATE.HANGAR) updateHangarUI();
            }
        }

        function devSkipWave() {
            const val = parseInt(document.getElementById('dev-wave').value);
            if (!isNaN(val) && val > 0 && gameState === STATE.PLAYING) {
                enemies = []; // Clear active enemies
                bullets = [];
                // If boss was active, deactivate it to prevent weird overlap
                if(boss.active) boss.active = false;
                startWave(val);
            }
        }

        function devKillAll() {
            if (gameState === STATE.PLAYING) {
                // Kill standard enemies
                enemies.forEach(e => e.hit(10000));
                
                // Kill boss (hit twice to bypass shield check if necessary)
                if (boss && boss.active) {
                    boss.hit(10000); 
                    boss.hit(10000);
                }
            }
        }

        function devResetStarsOnly() {
            gameData.easy.stars = 0;
            gameData.hard.stars = 0;
            saveData();
            updateUI();
            if (gameState === STATE.HANGAR) updateHangarUI();
            alert("Stars Reset!");
        }

        function devResetUpgradesOnly() {
            gameData.easy.healthLvl = 0;
            gameData.easy.cannonLvl = 0;
            gameData.hard.healthLvl = 0;
            gameData.hard.cannonLvl = 0;
            saveData();
            updateUI();
            if (gameState === STATE.HANGAR) updateHangarUI();
            alert("Upgrades Reset!");
        }

        function devResetLevelsOnly() {
            gameData.easy.maxStage = 1;
            gameData.hard.maxStage = 1;
            saveData();
            // Don't need updateUI here as level grid updates on view
            // If currently viewing level grid, refresh it:
            if (gameState === STATE.LEVEL_SELECT) {
               // Check which mode is visible by checking expert screen opacity
               const isExpert = document.getElementById('expert-level-select-screen').style.opacity === '1';
               updateLevelGrid(isExpert ? 'hard' : 'easy');
            }
            alert("Levels Reset to 1!");
        }

        function devUnlockStages() {
            gameData.easy.maxStage = 3;
            gameData.hard.maxStage = 3;
            saveData();
            if (gameState === STATE.LEVEL_SELECT) {
                const isExpert = document.getElementById('expert-level-select-screen').style.opacity === '1';
                updateLevelGrid(isExpert ? 'hard' : 'easy');
            }
            alert("All Stages Unlocked!");
        }

        function devGlobalWipe() {
            // "Global Data Wipe" - Nuclear option
            // 1. Clear Game Data
            // 2. Clear Visited Cookie
            // 3. Reload Page
            if(confirm("WARNING: This will wipe ALL progress (Stars, Upgrades, Levels) and reset the game to factory state (Welcome Screen). Continue?")) {
                localStorage.removeItem('neonVoidData_v3');
                localStorage.removeItem('neonVoid_visited');
                location.reload();
            }
        }
        
        // Renaming this function to clarify it's just for testing intro, distinct from full wipe
        function devResetCookies() {
            localStorage.removeItem('neonVoid_visited');
            alert("Intro Cookie Cleared. Refresh to see Welcome.");
        }

        // --- NEW WELCOME & COOKIE LOGIC ---
        function checkFirstVisit() {
            const visited = getCookie('neonVoid_visited');
            if (visited) {
                cookiesAccepted = true; // Assume true if they have the cookie
                initData(); // Load existing game data
                resetToMenu();
            } else {
                startWelcomeSequence();
            }
        }

        function startWelcomeSequence() {
            gameState = STATE.WELCOME;
            // Hide other screens
            menuScreen.style.opacity = '0';
            menuScreen.style.pointerEvents = 'none';
            // Show Welcome
            const screen = document.getElementById('welcome-screen');
            screen.style.opacity = '1';
            screen.style.pointerEvents = 'auto';
            
            // Step 1 Content
            document.getElementById('welcome-header').innerText = "SYSTEM BOOT";
            document.getElementById('welcome-content').innerHTML = 
                "Greetings, Pilot.<br><br>Welcome to the Neon Void. Your mission is to survive the sectors and neutralize the Rogue AI.<br><br>Are you ready to interface?";
            
            const footer = document.getElementById('welcome-footer');
            footer.innerHTML = `<button class="btn" style="border-color: #00ff00; color: #00ff00;" onclick="showCookieStep()">INITIATE LINK</button>`;
        }

        function showCookieStep() {
            document.getElementById('welcome-header').innerText = "PROTOCOL CHECK";
            document.getElementById('welcome-content').innerHTML = 
                "Systems initializing... <br><br>WARNING: Persistent Data Storage required.<br><br>But first... you gotta try these cookies. üç™<br>They allow us to save your progress.";
            
            const footer = document.getElementById('welcome-footer');
            footer.innerHTML = `
                <div style="display:flex; gap:20px; width:100%; justify-content:space-between;">
                    <button class="btn btn-hard" style="font-size:16px; padding:10px 20px;" onclick="handleCookies(false)">DENY (NO SAVE)</button>
                    <button class="btn" style="border-color:#00ff00; color:#00ff00; font-size:16px; padding:10px 20px;" onclick="handleCookies(true)">ACCEPT COOKIES</button>
                </div>
            `;
        }

        function handleCookies(accepted) {
            const screen = document.getElementById('welcome-screen');
            screen.style.opacity = '0';
            screen.style.pointerEvents = 'none';
            
            if (accepted) {
                cookiesAccepted = true;
                setCookie('neonVoid_visited', 'true', 365);
                initData(); // Load or init save data
                saveData(); // Save the fact that we inited
            } else {
                cookiesAccepted = false;
                initData(); // Init fresh data but won't save
            }
            
            resetToMenu();
        }

        document.getElementById('start-hard-btn').addEventListener('click', showExpertSelect);
        document.getElementById('start-easy-btn').addEventListener('click', showRookieSelect);
        if (typeof THREE !== 'undefined') initThreeMenu();
        
        // Start check
        checkFirstVisit();
        animateGame();
    </script>
</body>
</html>
